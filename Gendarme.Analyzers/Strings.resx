<?xml version="1.0" encoding="utf-8"?>

<root>
    <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
        <xsd:element name="root" msdata:IsDataSet="true">
            
        </xsd:element>
    </xsd:schema>
    <resheader name="resmimetype">
        <value>text/microsoft-resx</value>
    </resheader>
    <resheader name="version">
        <value>1.3</value>
    </resheader>
    <resheader name="reader">
        <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
    </resheader>
    <resheader name="writer">
        <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
    </resheader>
    <data name="AssemblyVersionMismatch_Description" xml:space="preserve">
        <value>All assembly version attributes should be consistent.</value>
    </data>
    <data name="AssemblyVersionMismatch_HelpLink" xml:space="preserve">
        <value>https://www.mono-project.com/docs/tools+libraries/tools/gendarme/rules/bad-practice/#avoidassemblyversionmismatchrule</value>
    </data>
    <data name="AssemblyVersionMismatch_Message" xml:space="preserve">
        <value>Assembly version '{0}' does not match other version attributes</value>
    </data>
    <data name="AssemblyVersionMismatch_Title" xml:space="preserve">
        <value>Assembly version mismatch</value>
    </data>
    <data name="AvoidCallingProblematicMethods_Description" xml:space="preserve">
        <value>Avoid using methods that are known to be problematic due to potential issues such as performance problems or incorrect behavior.</value>
    </data>
    <data name="AvoidCallingProblematicMethods_Message" xml:space="preserve">
        <value>Method '{0}' is considered problematic.</value>
    </data>
    <data name="AvoidCallingProblematicMethods_Title" xml:space="preserve">
        <value>Avoid problematic methods</value>
    </data>
    <data name="AvoidVisibleConstantField_Description" xml:space="preserve">
        <value>Avoid constant fields which are visible outside the current assembly. Use 'static readonly' instead.</value>
    </data>
    <data name="AvoidVisibleConstantField_Message" xml:space="preserve">
        <value>The constant field '{0}' is visible outside the assembly</value>
    </data>
    <data name="AvoidVisibleConstantField_Title" xml:space="preserve">
        <value>Avoid visible constant field</value>
    </data>
    <data name="CheckNewExceptionWithoutThrowing_Description" xml:space="preserve">
        <value>Exception objects should be thrown, returned, or passed to another method as an argument.</value>
    </data>
    <data name="CheckNewExceptionWithoutThrowing_Message" xml:space="preserve">
        <value>The exception '{0}' is created but not thrown, not returned, and not passed to another method</value>
    </data>
    <data name="CheckNewExceptionWithoutThrowing_Title" xml:space="preserve">
        <value>Exception object created but not thrown or used</value>
    </data>
    <data name="CheckNewThreadWithoutStart_Description" xml:space="preserve">
        <value>Thread objects should be started, returned, or passed to another method as an argument.</value>
    </data>
    <data name="CheckNewThreadWithoutStart_Message" xml:space="preserve">
        <value>The thread '{0}' is created but not started, not returned, and not passed to another method</value>
    </data>
    <data name="CheckNewThreadWithoutStart_Title" xml:space="preserve">
        <value>Thread object created but not started or used</value>
    </data>
    <data name="CloneMethodShouldNotReturnNull_Description" xml:space="preserve">
        <value>Clone methods should not return null. They should return a new object instance.</value>
    </data>
    <data name="CloneMethodShouldNotReturnNull_Message" xml:space="preserve">
        <value>The Clone method returns null</value>
    </data>
    <data name="CloneMethodShouldNotReturnNull_Title" xml:space="preserve">
        <value>Clone method should not return null</value>
    </data>
    <data name="ConstructorShouldNotCallVirtualMethods_Description" xml:space="preserve">
        <value>Constructors of non-sealed types should not call virtual methods. This can lead to fragile code if the method is overridden in a derived class.</value>
    </data>
    <data name="ConstructorShouldNotCallVirtualMethods_Message" xml:space="preserve">
        <value>The constructor calls the virtual method '{0}'</value>
    </data>
    <data name="ConstructorShouldNotCallVirtualMethods_Title" xml:space="preserve">
        <value>Constructor should not call virtual methods</value>
    </data>
    <data name="DisableDebuggingCode_Description" xml:space="preserve">
        <value>Non-console applications should not contain calls to Console.WriteLine. Use Debug.WriteLine or Conditional(\"DEBUG\") instead.</value>
    </data>
    <data name="DisableDebuggingCode_Message" xml:space="preserve">
        <value>The method '{0}' contains a call to Console.WriteLine</value>
    </data>
    <data name="DisableDebuggingCode_Title" xml:space="preserve">
        <value>Disable debugging code in non-console applications</value>
    </data>
    <data name="DoNotForgetNotImplementedMethods_Description" xml:space="preserve">
        <value>Methods throwing NotImplementedException should be implemented before release.</value>
    </data>
    <data name="DoNotForgetNotImplementedMethods_Message" xml:space="preserve">
        <value>The method '{0}' throws a NotImplementedException</value>
    </data>
    <data name="DoNotForgetNotImplementedMethods_Title" xml:space="preserve">
        <value>Do not forget NotImplemented methods</value>
    </data>
    <data name="DoNotLockOnThisOrTypesAnalyzer_Description" xml:space="preserve">
        <value>Using 'lock (this)' or 'lock (typeof(...))' can cause deadlocks. Use a private lock object instead.</value>
    </data>
    <data name="DoNotLockOnThisOrTypesAnalyzer_Message" xml:space="preserve">
        <value>Do not lock on 'this' or 'Type' to avoid deadlocks</value>
    </data>
    <data name="DoNotLockOnThisOrTypesAnalyzer_Title" xml:space="preserve">
        <value>Do not lock on 'this' or 'Type'</value>
    </data>
    <data name="DoNotLockOnWeakIdentityObjectsAnalyzer_Description" xml:space="preserve">
        <value>Locking on objects with weak identity (e.g., strings, exceptions) can cause deadlocks. Use a private lock object instead.</value>
    </data>
    <data name="DoNotLockOnWeakIdentityObjectsAnalyzer_Message" xml:space="preserve">
        <value>Do not lock on objects with weak identity to avoid deadlocks</value>
    </data>
    <data name="DoNotLockOnWeakIdentityObjectsAnalyzer_Title" xml:space="preserve">
        <value>Do not lock on objects with weak identity</value>
    </data>
    <data name="DoNotUseEnumIsAssignableFrom_Description" xml:space="preserve">
        <value>Calls to typeof(Enum).IsAssignableFrom(type) can be simplified to type.IsEnum.</value>
    </data>
    <data name="DoNotUseEnumIsAssignableFrom_Message" xml:space="preserve">
        <value>Replace 'typeof(Enum).IsAssignableFrom({0})' with '{0}.IsEnum'</value>
    </data>
    <data name="DoNotUseEnumIsAssignableFrom_Title" xml:space="preserve">
        <value>Use type.IsEnum instead of typeof(Enum).IsAssignableFrom(type)</value>
    </data>
    <data name="DoNotUseLockedRegionOutsideMethodAnalyzer_Description" xml:space="preserve">
        <value>Using Monitor.Enter without Monitor.Exit in the same method can lead to deadlocks and is difficult to maintain.</value>
    </data>
    <data name="DoNotUseLockedRegionOutsideMethodAnalyzer_Message" xml:space="preserve">
        <value>Do not use Monitor.Enter without corresponding Monitor.Exit in the same method</value>
    </data>
    <data name="DoNotUseLockedRegionOutsideMethodAnalyzer_Title" xml:space="preserve">
        <value>Do not use locked region outside method</value>
    </data>
    <data name="DoNotUseMethodImplOptionsSynchronizedAnalyzer_Description" xml:space="preserve">
        <value>Using MethodImplOptions.Synchronized causes a lock(this) or lock(typeof(...)) which can cause deadlocks. Use a private lock object instead.</value>
    </data>
    <data name="DoNotUseMethodImplOptionsSynchronizedAnalyzer_Message" xml:space="preserve">
        <value>Do not use MethodImplOptions.Synchronized on method '{0}'</value>
    </data>
    <data name="DoNotUseMethodImplOptionsSynchronizedAnalyzer_Title" xml:space="preserve">
        <value>Do not use MethodImplOptions.Synchronized</value>
    </data>
    <data name="DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Description" xml:space="preserve">
        <value>The ThreadStatic attribute can only be applied to static fields. Applying it to instance fields is ineffective.</value>
    </data>
    <data name="DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Message" xml:space="preserve">
        <value>The field '{0}' is an instance field with the ThreadStatic attribute, which is ineffective</value>
    </data>
    <data name="DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Title" xml:space="preserve">
        <value>Do not use ThreadStatic attribute with instance fields</value>
    </data>
    <data name="DoubleCheckLockingAnalyzer_Description" xml:space="preserve">
        <value>Double-check locking can be problematic in older versions of .NET. Ensure it is used correctly.</value>
    </data>
    <data name="DoubleCheckLockingAnalyzer_Message" xml:space="preserve">
        <value>Avoid double-check locking on '{0}'</value>
    </data>
    <data name="DoubleCheckLockingAnalyzer_Title" xml:space="preserve">
        <value>Avoid double-check locking</value>
    </data>
    <data name="EqualsShouldHandleNullArg_Description" xml:space="preserve">
        <value>Equals(object) methods should return false when the object parameter is null.</value>
    </data>
    <data name="EqualsShouldHandleNullArg_Message" xml:space="preserve">
        <value>Equals method does not handle null argument</value>
    </data>
    <data name="EqualsShouldHandleNullArg_Title" xml:space="preserve">
        <value>Equals method should handle null argument</value>
    </data>
    <data name="GetEntryAssemblyMayReturnNull_Description" xml:space="preserve">
        <value>Calls to Assembly.GetEntryAssembly() may return null in libraries or DLLs. Ensure proper null handling.</value>
    </data>
    <data name="GetEntryAssemblyMayReturnNull_Message" xml:space="preserve">
        <value>Assembly.GetEntryAssembly may return null when called from a library or DLL</value>
    </data>
    <data name="GetEntryAssemblyMayReturnNull_Title" xml:space="preserve">
        <value>Assembly.GetEntryAssembly may return null</value>
    </data>
    <data name="NonConstantStaticFieldsShouldNotBeVisible_Description" xml:space="preserve">
        <value>Public static fields should be constant or readonly to avoid synchronization issues.</value>
    </data>
    <data name="NonConstantStaticFieldsShouldNotBeVisible_Message" xml:space="preserve">
        <value>The static field '{0}' should not be publicly visible</value>
    </data>
    <data name="NonConstantStaticFieldsShouldNotBeVisible_Title" xml:space="preserve">
        <value>Non-constant static fields should not be visible</value>
    </data>
    <data name="ObsoleteMessagesShouldNotBeEmpty_Description" xml:space="preserve">
        <value>The Obsolete attribute is more helpful if it includes advice on how to deal with the situation (e.g., the new recommended API to use).</value>
    </data>
    <data name="ObsoleteMessagesShouldNotBeEmpty_Message" xml:space="preserve">
        <value>The Obsolete attribute on '{0}' should include a message providing guidance.</value>
    </data>
    <data name="ObsoleteMessagesShouldNotBeEmpty_Title" xml:space="preserve">
        <value>Obsolete attribute should not be empty</value>
    </data>
    <data name="OnlyUseDisposeForIDisposableTypes_Description" xml:space="preserve">
        <value>Methods named Dispose should be reserved for types that implement IDisposable to avoid confusing developers.</value>
    </data>
    <data name="OnlyUseDisposeForIDisposableTypes_Message" xml:space="preserve">
        <value>The method '{0}' is named Dispose but the containing type does not implement IDisposable</value>
    </data>
    <data name="OnlyUseDisposeForIDisposableTypes_Title" xml:space="preserve">
        <value>Methods named Dispose should be reserved for types that implement IDisposable</value>
    </data>
    <data name="PreferEmptyInstanceOverNull_Description" xml:space="preserve">
        <value>Methods and properties which return a string, an array, a collection, or an enumerable should return an empty instance rather than null.</value>
    </data>
    <data name="PreferEmptyInstanceOverNull_Message" xml:space="preserve">
        <value>The method or property '{0}' returns null; consider returning an empty instance instead</value>
    </data>
    <data name="PreferEmptyInstanceOverNull_Title" xml:space="preserve">
        <value>Prefer returning an empty instance over null</value>
    </data>
    <data name="PreferSafeHandle_Description" xml:space="preserve">
        <value>It is recommended to use SafeHandle instead of IntPtr or UIntPtr for handling unmanaged resources.</value>
    </data>
    <data name="PreferSafeHandle_Message" xml:space="preserve">
        <value>Consider using SafeHandle instead of {0} for better resource management and safety</value>
    </data>
    <data name="PreferSafeHandle_Title" xml:space="preserve">
        <value>Prefer SafeHandle over IntPtr or UIntPtr for unmanaged resources</value>
    </data>
    <data name="ProtectCallToEventDelegatesAnalyzer_Description" xml:space="preserve">
        <value>Event delegates should be checked for null and copied to a local variable to avoid race conditions.</value>
    </data>
    <data name="ProtectCallToEventDelegatesAnalyzer_Message" xml:space="preserve">
        <value>The event '{0}' should be checked for null before invocation</value>
    </data>
    <data name="ProtectCallToEventDelegatesAnalyzer_Title" xml:space="preserve">
        <value>Protect call to event delegates</value>
    </data>
    <data name="ReplaceIncompleteOddnessCheck_Description" xml:space="preserve">
        <value>Using '(x % 2) == 1' to check for odd numbers will fail for negative numbers. Use '(x % 2 != 0)' or '(x &amp; 1 == 1)' instead.</value>
    </data>
    <data name="ReplaceIncompleteOddnessCheck_Message" xml:space="preserve">
        <value>The modulo operation used to check oddness may fail for negative numbers; consider using '(x % 2 != 0)' or '(x &amp; 1 == 1)'</value>
    </data>
    <data name="ReplaceIncompleteOddnessCheck_Title" xml:space="preserve">
        <value>Replace incomplete oddness check</value>
    </data>
    <data name="ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Description" xml:space="preserve">
        <value>Locks should be used only for operations on variables. Consider using Interlocked for atomic operations.</value>
    </data>
    <data name="ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Message" xml:space="preserve">
        <value>The lock on '{0}' should be reviewed to ensure it is necessary</value>
    </data>
    <data name="ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Title" xml:space="preserve">
        <value>Review lock used only for operations on variables</value>
    </data>
    <data name="ToStringShouldNotReturnNull_Description" xml:space="preserve">
        <value>Overridden ToString() methods should not return null. An appropriately descriptive string, or string.Empty, should be returned instead to make the value more useful.</value>
    </data>
    <data name="ToStringShouldNotReturnNull_Message" xml:space="preserve">
        <value>The ToString() method returns null; consider returning a descriptive string or string.Empty</value>
    </data>
    <data name="ToStringShouldNotReturnNull_Title" xml:space="preserve">
        <value>ToString() should not return null</value>
    </data>
    <data name="WriteStaticFieldFromInstanceMethod_Description" xml:space="preserve">
        <value>Writing to static fields from instance methods can cause issues in multithreaded environments. Consider refactoring to avoid this pattern.</value>
    </data>
    <data name="WriteStaticFieldFromInstanceMethod_Message" xml:space="preserve">
        <value>The instance method '{0}' writes to static field '{1}', which can cause issues in multithreaded environments</value>
    </data>
    <data name="WriteStaticFieldFromInstanceMethod_Title" xml:space="preserve">
        <value>Do not write to static fields from instance methods</value>
    </data>
    <data name="AttributeStringLiteralsShouldParseCorrectly_Description" xml:space="preserve">
        <value>This rule checks attributes with certain types (Version, Guid, Uri) and validates the string value.</value>
    </data>
    <data name="AttributeStringLiteralsShouldParseCorrectly_Message" xml:space="preserve">
        <value>String literal in attribute does not parse correctly: '{0}'</value>
    </data>
    <data name="AttributeStringLiteralsShouldParseCorrectly_Title" xml:space="preserve">
        <value>Attribute string literals should parse correctly</value>
    </data>
    <data name="AvoidConstructorsInStaticTypes_Description" xml:space="preserve">
        <value>This rule checks for types that contain only static members and fires if the type contains a visible instance constructor.</value>
    </data>
    <data name="AvoidConstructorsInStaticTypes_Message" xml:space="preserve">
        <value>Static type '{0}' contains a constructor</value>
    </data>
    <data name="AvoidConstructorsInStaticTypes_Title" xml:space="preserve">
        <value>Avoid constructors in static types</value>
    </data>
    <data name="AvoidFloatingPointEquality_Description" xml:space="preserve">
        <value>In general floating point numbers cannot be usefully compared using the equality and inequality operators.</value>
    </data>
    <data name="AvoidFloatingPointEquality_Message" xml:space="preserve">
        <value>Floating point comparison with equality operator may cause unexpected results</value>
    </data>
    <data name="AvoidFloatingPointEquality_Title" xml:space="preserve">
        <value>Avoid floating point equality comparison</value>
    </data>
    <data name="BadRecursiveInvocation_Description" xml:space="preserve">
        <value>This rule checks for methods that may be infinitely recursive.</value>
    </data>
    <data name="BadRecursiveInvocation_Message" xml:space="preserve">
        <value>Method '{0}' recursively calls itself</value>
    </data>
    <data name="BadRecursiveInvocation_Title" xml:space="preserve">
        <value>Avoid bad recursive invocation</value>
    </data>
    <data name="CallingEqualsWithNullArg_Description" xml:space="preserve">
        <value>This rule checks for methods that call Equals with a null actual parameter.</value>
    </data>
    <data name="CallingEqualsWithNullArg_Message" xml:space="preserve">
        <value>Method '{0}' calls Equals with a null argument</value>
    </data>
    <data name="CallingEqualsWithNullArg_Title" xml:space="preserve">
        <value>Avoid calling Equals with null argument</value>
    </data>
    <data name="CheckParametersNullityInVisibleMethods_Description" xml:space="preserve">
        <value>This rule checks if all nullable parameters of visible methods are compared with null before they get used.</value>
    </data>
    <data name="CheckParametersNullityInVisibleMethods_Message" xml:space="preserve">
        <value>Parameter '{0}' is not checked for null</value>
    </data>
    <data name="CheckParametersNullityInVisibleMethods_Title" xml:space="preserve">
        <value>Check nullable parameters for null before use</value>
    </data>
    <data name="DisposableFieldsShouldBeDisposed_Description" xml:space="preserve">
        <value>The rule inspects all fields for disposable types and checks that the type’s Dispose method calls Dispose on all disposable fields.</value>
    </data>
    <data name="DisposableFieldsShouldBeDisposed_Message" xml:space="preserve">
        <value>Field '{0}' is not disposed</value>
    </data>
    <data name="DisposableFieldsShouldBeDisposed_Title" xml:space="preserve">
        <value>Disposable fields should be disposed</value>
    </data>
    <data name="DoNotCompareWithNaN_Description" xml:space="preserve">
        <value>As defined in IEEE 754 it’s impossible to compare any floating-point value, even another NaN, with NaN.</value>
    </data>
    <data name="DoNotCompareWithNaN_Message" xml:space="preserve">
        <value>Comparison with NaN always returns false</value>
    </data>
    <data name="DoNotCompareWithNaN_Title" xml:space="preserve">
        <value>Do not compare with NaN</value>
    </data>
    <data name="DoNotRecurseInEquality_Description" xml:space="preserve">
        <value>An equality operator (==) orinequality operator (!=) method is calling itself recursively.</value>
    </data>
    <data name="DoNotRecurseInEquality_Message" xml:space="preserve">
        <value>Equality operator calls itself recursively</value>
    </data>
    <data name="DoNotRecurseInEquality_Title" xml:space="preserve">
        <value>Do not recurse in equality operator</value>
    </data>
    <data name="DoNotRoundIntegers_Description" xml:space="preserve">
        <value>This rule checks for attempts to call Round, Ceiling, Floor or Truncate on an integral type.</value>
    </data>
    <data name="DoNotRoundIntegers_Message" xml:space="preserve">
        <value>Rounding operation on an integer is redundant</value>
    </data>
    <data name="DoNotRoundIntegers_Title" xml:space="preserve">
        <value>Do not round integers</value>
    </data>
    <data name="EnsureLocalDisposal_Description" xml:space="preserve">
        <value>This rule checks that disposable locals are always disposed of before the method returns.</value>
    </data>
    <data name="EnsureLocalDisposal_Message" xml:space="preserve">
        <value>Local disposable object '{0}' is not disposed</value>
    </data>
    <data name="EnsureLocalDisposal_Title" xml:space="preserve">
        <value>Ensure local disposal</value>
    </data>
    <data name="FinalizersShouldCallBaseClassFinalizer_Description" xml:space="preserve">
        <value>This rule checks that a finalizer calls the base class finalizer.</value>
    </data>
    <data name="FinalizersShouldCallBaseClassFinalizer_Message" xml:space="preserve">
        <value>Finalizer does not call the base class finalizer</value>
    </data>
    <data name="FinalizersShouldCallBaseClassFinalizer_Title" xml:space="preserve">
        <value>Finalizers should call base class finalizer</value>
    </data>
    <data name="MethodCanBeMadeStatic_Description" xml:space="preserve">
        <value>This rule checks for methods that do not require anything from the current instance and can be converted into static methods.</value>
    </data>
    <data name="MethodCanBeMadeStatic_Message" xml:space="preserve">
        <value>Method '{0}' can be made static</value>
    </data>
    <data name="MethodCanBeMadeStatic_Title" xml:space="preserve">
        <value>Method can be made static</value>
    </data>
    <data name="ProvideCorrectArgumentsToFormattingMethods_Description" xml:space="preserve">
        <value>This rule checks that the format string used with String.Format matches the other parameters used with the method.</value>
    </data>
    <data name="ProvideCorrectArgumentsToFormattingMethods_Message" xml:space="preserve">
        <value>The format string in '{0}' does not match the arguments provided</value>
    </data>
    <data name="ProvideCorrectArgumentsToFormattingMethods_Title" xml:space="preserve">
        <value>Provide correct arguments to formatting methods</value>
    </data>
    <data name="ProvideCorrectRegexPattern_Description" xml:space="preserve">
        <value>This rule verifies that valid regular expression strings are used as arguments.</value>
    </data>
    <data name="ProvideCorrectRegexPattern_Message" xml:space="preserve">
        <value>Invalid regex pattern in '{0}'</value>
    </data>
    <data name="ProvideCorrectRegexPattern_Title" xml:space="preserve">
        <value>Provide correct regex pattern</value>
    </data>
    <data name="ProvideValidXmlString_Description" xml:space="preserve">
        <value>This rule verifies that valid XML string arguments are passed as arguments.</value>
    </data>
    <data name="ProvideValidXmlString_Message" xml:space="preserve">
        <value>Invalid XML string in '{0}'</value>
    </data>
    <data name="ProvideValidXmlString_Title" xml:space="preserve">
        <value>Provide valid XML string</value>
    </data>
    <data name="ProvideValidXPathExpression_Description" xml:space="preserve">
        <value>This rule verifies that valid XPath expression strings are passed as arguments.</value>
    </data>
    <data name="ProvideValidXPathExpression_Message" xml:space="preserve">
        <value>Invalid XPath expression in '{0}'</value>
    </data>
    <data name="ProvideValidXPathExpression_Title" xml:space="preserve">
        <value>Provide valid XPath expression</value>
    </data>
    <data name="ReviewCastOnIntegerDivision_Description" xml:space="preserve">
        <value>This rule checks for integral divisions where the result is cast to a floating point type.</value>
    </data>
    <data name="ReviewCastOnIntegerDivision_Message" xml:space="preserve">
        <value>Cast on integer division may cause truncation</value>
    </data>
    <data name="ReviewCastOnIntegerDivision_Title" xml:space="preserve">
        <value>Review cast on integer division</value>
    </data>
    <data name="ReviewCastOnIntegerMultiplication_Description" xml:space="preserve">
        <value>This rule checks for integral multiply operations where the result is cast to a larger integral type.</value>
    </data>
    <data name="ReviewCastOnIntegerMultiplication_Message" xml:space="preserve">
        <value>Cast on integer multiplication may cause overflow</value>
    </data>
    <data name="ReviewCastOnIntegerMultiplication_Title" xml:space="preserve">
        <value>Review cast on integer multiplication</value>
    </data>
    <data name="ReviewDoubleAssignment_Description" xml:space="preserve">
        <value>This rule checks for variables or fields that are assigned multiple times using the same value.</value>
    </data>
    <data name="ReviewDoubleAssignment_Message" xml:space="preserve">
        <value>Variable '{0}' is assigned twice with the same value</value>
    </data>
    <data name="ReviewDoubleAssignment_Title" xml:space="preserve">
        <value>Review double assignment</value>
    </data>
    <data name="ReviewInconsistentIdentity_Description" xml:space="preserve">
        <value>This rule checks to see if a type manages its identity in a consistent way.</value>
    </data>
    <data name="ReviewInconsistentIdentity_Message" xml:space="preserve">
        <value>Identity management for '{0}' is inconsistent</value>
    </data>
    <data name="ReviewInconsistentIdentity_Title" xml:space="preserve">
        <value>Review inconsistent identity management</value>
    </data>
    <data name="ReviewSelfAssignment_Description" xml:space="preserve">
        <value>This rule checks for variables or fields that are assigned to themselves.</value>
    </data>
    <data name="ReviewSelfAssignment_Message" xml:space="preserve">
        <value>Variable '{0}' is assigned to itself</value>
    </data>
    <data name="ReviewSelfAssignment_Title" xml:space="preserve">
        <value>Review self-assignment</value>
    </data>
    <data name="ReviewUselessControlFlow_Description" xml:space="preserve">
        <value>This rule checks for empty blocks that produce useless control flow inside IL.</value>
    </data>
    <data name="ReviewUselessControlFlow_Message" xml:space="preserve">
        <value>Useless control flow detected</value>
    </data>
    <data name="ReviewUselessControlFlow_Title" xml:space="preserve">
        <value>Review useless control flow</value>
    </data>
    <data name="ReviewUseOfInt64BitsToDouble_Description" xml:space="preserve">
        <value>This rule checks for invalid integer to double conversion using BitConverter.Int64BitsToDouble method.</value>
    </data>
    <data name="ReviewUseOfInt64BitsToDouble_Message" xml:space="preserve">
        <value>Invalid use of BitConverter.Int64BitsToDouble</value>
    </data>
    <data name="ReviewUseOfInt64BitsToDouble_Title" xml:space="preserve">
        <value>Review use of Int64BitsToDouble</value>
    </data>
    <data name="ReviewUseOfModuloOneOnIntegers_Description" xml:space="preserve">
        <value>This rule checks for a modulo one operation on an integral type.</value>
    </data>
    <data name="ReviewUseOfModuloOneOnIntegers_Message" xml:space="preserve">
        <value>Modulo one operation on an integer is likely a typo</value>
    </data>
    <data name="ReviewUseOfModuloOneOnIntegers_Title" xml:space="preserve">
        <value>Review use of modulo one on integers</value>
    </data>
    <data name="UseValueInPropertySetter_Description" xml:space="preserve">
        <value>Use value in property setter</value>
    </data>
    <data name="UseValueInPropertySetter_Message" xml:space="preserve">
        <value>Property setter does not use 'value'</value>
    </data>
    <data name="UseValueInPropertySetter_Title" xml:space="preserve">
        <value>This rule ensures all setter properties uses the value argument passed to the property.</value>
    </data>
</root>