<?xml version="1.0" encoding="utf-8"?>
<root>
    <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
        <xsd:element name="root" msdata:IsDataSet="true">
        </xsd:element>
    </xsd:schema>
    <resheader name="resmimetype">
        <value>text/microsoft-resx</value>
    </resheader>
    <resheader name="version">
        <value>1.3</value>
    </resheader>
    <resheader name="reader">
        <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral,
            PublicKeyToken=b77a5c561934e089
        </value>
    </resheader>
    <resheader name="writer">
        <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral,
            PublicKeyToken=b77a5c561934e089
        </value>
    </resheader>
    <data name="AssemblyVersionMismatch_Description" xml:space="preserve">
        <value>All assembly version attributes should be consistent.</value>
    </data>
    <data name="AssemblyVersionMismatch_HelpLink" xml:space="preserve">
        <value>https://www.mono-project.com/docs/tools+libraries/tools/gendarme/rules/bad-practice/#avoidassemblyversionmismatchrule</value>
    </data>
    <data name="AssemblyVersionMismatch_Message" xml:space="preserve">
        <value>Assembly version '{0}' does not match other version attributes</value>
    </data>
    <data name="AssemblyVersionMismatch_Title" xml:space="preserve">
        <value>Assembly version mismatch</value>
    </data>
    <data name="AvoidCallingProblematicMethods_Description" xml:space="preserve">
        <value>Avoid using methods that are known to be problematic due to potential issues such as performance problems or incorrect behavior.</value>
    </data>
    <data name="AvoidCallingProblematicMethods_Message" xml:space="preserve">
        <value>Method '{0}' is considered problematic.</value>
    </data>
    <data name="AvoidCallingProblematicMethods_Title" xml:space="preserve">
        <value>Avoid problematic methods</value>
    </data>
    <data name="AvoidVisibleConstantField_Description" xml:space="preserve">
        <value>Avoid constant fields which are visible outside the current assembly. Use 'static readonly' instead.</value>
    </data>
    <data name="AvoidVisibleConstantField_Message" xml:space="preserve">
        <value>The constant field '{0}' is visible outside the assembly</value>
    </data>
    <data name="AvoidVisibleConstantField_Title" xml:space="preserve">
        <value>Avoid visible constant field</value>
    </data>
    <data name="CheckNewExceptionWithoutThrowing_Description" xml:space="preserve">
        <value>Exception objects should be thrown, returned, or passed to another method as an argument.</value>
    </data>
    <data name="CheckNewExceptionWithoutThrowing_Message" xml:space="preserve">
        <value>The exception '{0}' is created but not thrown, not returned, and not passed to another method</value>
    </data>
    <data name="CheckNewExceptionWithoutThrowing_Title" xml:space="preserve">
        <value>Exception object created but not thrown or used</value>
    </data>
    <data name="CheckNewThreadWithoutStart_Description" xml:space="preserve">
        <value>Thread objects should be started, returned, or passed to another method as an argument.</value>
    </data>
    <data name="CheckNewThreadWithoutStart_Message" xml:space="preserve">
        <value>The thread '{0}' is created but not started, not returned, and not passed to another method</value>
    </data>
    <data name="CheckNewThreadWithoutStart_Title" xml:space="preserve">
        <value>Thread object created but not started or used</value>
    </data>
    <data name="CloneMethodShouldNotReturnNull_Description" xml:space="preserve">
        <value>Clone methods should not return null. They should return a new object instance.</value>
    </data>
    <data name="CloneMethodShouldNotReturnNull_Message" xml:space="preserve">
        <value>The Clone method returns null</value>
    </data>
    <data name="CloneMethodShouldNotReturnNull_Title" xml:space="preserve">
        <value>Clone method should not return null</value>
    </data>
    <data name="ConstructorShouldNotCallVirtualMethods_Description" xml:space="preserve">
        <value>Constructors of non-sealed types should not call virtual methods. This can lead to fragile code if the method is overridden in a derived class.</value>
    </data>
    <data name="ConstructorShouldNotCallVirtualMethods_Message" xml:space="preserve">
        <value>The constructor calls the virtual method '{0}'</value>
    </data>
    <data name="ConstructorShouldNotCallVirtualMethods_Title" xml:space="preserve">
        <value>Constructor should not call virtual methods</value>
    </data>
    <data name="DisableDebuggingCode_Description" xml:space="preserve">
        <value>Non-console applications should not contain calls to Console.WriteLine. Use Debug.WriteLine or Conditional(\"DEBUG\") instead.</value>
    </data>
    <data name="DisableDebuggingCode_Message" xml:space="preserve">
        <value>The method '{0}' contains a call to Console.WriteLine</value>
    </data>
    <data name="DisableDebuggingCode_Title" xml:space="preserve">
        <value>Disable debugging code in non-console applications</value>
    </data>
    <data name="DoNotForgetNotImplementedMethods_Description" xml:space="preserve">
        <value>Methods throwing NotImplementedException should be implemented before release.</value>
    </data>
    <data name="DoNotForgetNotImplementedMethods_Message" xml:space="preserve">
        <value>The method '{0}' throws a NotImplementedException</value>
    </data>
    <data name="DoNotForgetNotImplementedMethods_Title" xml:space="preserve">
        <value>Do not forget NotImplemented methods</value>
    </data>
    <data name="DoNotLockOnThisOrTypesAnalyzer_Description" xml:space="preserve">
        <value>Using 'lock (this)' or 'lock (typeof(...))' can cause deadlocks. Use a private lock object instead.</value>
    </data>
    <data name="DoNotLockOnThisOrTypesAnalyzer_Message" xml:space="preserve">
        <value>Do not lock on 'this' or 'Type' to avoid deadlocks</value>
    </data>
    <data name="DoNotLockOnThisOrTypesAnalyzer_Title" xml:space="preserve">
        <value>Do not lock on 'this' or 'Type'</value>
    </data>
    <data name="DoNotLockOnWeakIdentityObjectsAnalyzer_Description" xml:space="preserve">
        <value>Locking on objects with weak identity (e.g., strings, exceptions) can cause deadlocks. Use a private lock object instead.</value>
    </data>
    <data name="DoNotLockOnWeakIdentityObjectsAnalyzer_Message" xml:space="preserve">
        <value>Do not lock on objects with weak identity to avoid deadlocks</value>
    </data>
    <data name="DoNotLockOnWeakIdentityObjectsAnalyzer_Title" xml:space="preserve">
        <value>Do not lock on objects with weak identity</value>
    </data>
    <data name="DoNotUseEnumIsAssignableFrom_Description" xml:space="preserve">
        <value>Calls to typeof(Enum).IsAssignableFrom(type) can be simplified to type.IsEnum.</value>
    </data>
    <data name="DoNotUseEnumIsAssignableFrom_Message" xml:space="preserve">
        <value>Replace 'typeof(Enum).IsAssignableFrom({0})' with '{0}.IsEnum'</value>
    </data>
    <data name="DoNotUseEnumIsAssignableFrom_Title" xml:space="preserve">
        <value>Use type.IsEnum instead of typeof(Enum).IsAssignableFrom(type)</value>
    </data>
    <data name="DoNotUseLockedRegionOutsideMethodAnalyzer_Description" xml:space="preserve">
        <value>Using Monitor.Enter without Monitor.Exit in the same method can lead to deadlocks and is difficult to maintain.</value>
    </data>
    <data name="DoNotUseLockedRegionOutsideMethodAnalyzer_Message" xml:space="preserve">
        <value>Do not use Monitor.Enter without corresponding Monitor.Exit in the same method</value>
    </data>
    <data name="DoNotUseLockedRegionOutsideMethodAnalyzer_Title" xml:space="preserve">
        <value>Do not use locked region outside method</value>
    </data>
    <data name="DoNotUseMethodImplOptionsSynchronizedAnalyzer_Description" xml:space="preserve">
        <value>Using MethodImplOptions.Synchronized causes a lock(this) or lock(typeof(...)) which can cause deadlocks. Use a private lock object instead.</value>
    </data>
    <data name="DoNotUseMethodImplOptionsSynchronizedAnalyzer_Message" xml:space="preserve">
        <value>Do not use MethodImplOptions.Synchronized on method '{0}'</value>
    </data>
    <data name="DoNotUseMethodImplOptionsSynchronizedAnalyzer_Title" xml:space="preserve">
        <value>Do not use MethodImplOptions.Synchronized</value>
    </data>
    <data name="DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Description" xml:space="preserve">
        <value>The ThreadStatic attribute can only be applied to static fields. Applying it to instance fields is ineffective.</value>
    </data>
    <data name="DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Message" xml:space="preserve">
        <value>The field '{0}' is an instance field with the ThreadStatic attribute, which is ineffective</value>
    </data>
    <data name="DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Title" xml:space="preserve">
        <value>Do not use ThreadStatic attribute with instance fields</value>
    </data>
    <data name="DoubleCheckLockingAnalyzer_Description" xml:space="preserve">
        <value>Double-check locking can be problematic in older versions of .NET. Ensure it is used correctly.</value>
    </data>
    <data name="DoubleCheckLockingAnalyzer_Message" xml:space="preserve">
        <value>Avoid double-check locking on '{0}'</value>
    </data>
    <data name="DoubleCheckLockingAnalyzer_Title" xml:space="preserve">
        <value>Avoid double-check locking</value>
    </data>
    <data name="EqualsShouldHandleNullArg_Description" xml:space="preserve">
        <value>Equals(object) methods should return false when the object parameter is null.</value>
    </data>
    <data name="EqualsShouldHandleNullArg_Message" xml:space="preserve">
        <value>Equals method does not handle null argument</value>
    </data>
    <data name="EqualsShouldHandleNullArg_Title" xml:space="preserve">
        <value>Equals method should handle null argument</value>
    </data>
    <data name="GetEntryAssemblyMayReturnNull_Description" xml:space="preserve">
        <value>Calls to Assembly.GetEntryAssembly() may return null in libraries or DLLs. Ensure proper null handling.</value>
    </data>
    <data name="GetEntryAssemblyMayReturnNull_Message" xml:space="preserve">
        <value>Assembly.GetEntryAssembly may return null when called from a library or DLL</value>
    </data>
    <data name="GetEntryAssemblyMayReturnNull_Title" xml:space="preserve">
        <value>Assembly.GetEntryAssembly may return null</value>
    </data>
    <data name="NonConstantStaticFieldsShouldNotBeVisible_Description" xml:space="preserve">
        <value>Public static fields should be constant or readonly to avoid synchronization issues.</value>
    </data>
    <data name="NonConstantStaticFieldsShouldNotBeVisible_Message" xml:space="preserve">
        <value>The static field '{0}' should not be publicly visible</value>
    </data>
    <data name="NonConstantStaticFieldsShouldNotBeVisible_Title" xml:space="preserve">
        <value>Non-constant static fields should not be visible</value>
    </data>
    <data name="ObsoleteMessagesShouldNotBeEmpty_Description" xml:space="preserve">
        <value>The Obsolete attribute is more helpful if it includes advice on how to deal with the situation (e.g., the new recommended API to use).</value>
    </data>
    <data name="ObsoleteMessagesShouldNotBeEmpty_Message" xml:space="preserve">
        <value>The Obsolete attribute on '{0}' should include a message providing guidance.</value>
    </data>
    <data name="ObsoleteMessagesShouldNotBeEmpty_Title" xml:space="preserve">
        <value>Obsolete attribute should not be empty</value>
    </data>
    <data name="OnlyUseDisposeForIDisposableTypes_Description" xml:space="preserve">
        <value>Methods named Dispose should be reserved for types that implement IDisposable to avoid confusing developers.</value>
    </data>
    <data name="OnlyUseDisposeForIDisposableTypes_Message" xml:space="preserve">
        <value>The method '{0}' is named Dispose but the containing type does not implement IDisposable</value>
    </data>
    <data name="OnlyUseDisposeForIDisposableTypes_Title" xml:space="preserve">
        <value>Methods named Dispose should be reserved for types that implement IDisposable</value>
    </data>
    <data name="PreferEmptyInstanceOverNull_Description" xml:space="preserve">
        <value>Methods and properties which return a string, an array, a collection, or an enumerable should return an empty instance rather than null.</value>
    </data>
    <data name="PreferEmptyInstanceOverNull_Message" xml:space="preserve">
        <value>The method or property '{0}' returns null; consider returning an empty instance instead</value>
    </data>
    <data name="PreferEmptyInstanceOverNull_Title" xml:space="preserve">
        <value>Prefer returning an empty instance over null</value>
    </data>
    <data name="PreferSafeHandle_Description" xml:space="preserve">
        <value>It is recommended to use SafeHandle instead of IntPtr or UIntPtr for handling unmanaged resources.</value>
    </data>
    <data name="PreferSafeHandle_Message" xml:space="preserve">
        <value>Consider using SafeHandle instead of {0} for better resource management and safety</value>
    </data>
    <data name="PreferSafeHandle_Title" xml:space="preserve">
        <value>Prefer SafeHandle over IntPtr or UIntPtr for unmanaged resources</value>
    </data>
    <data name="ProtectCallToEventDelegatesAnalyzer_Description" xml:space="preserve">
        <value>Event delegates should be checked for null and copied to a local variable to avoid race conditions.</value>
    </data>
    <data name="ProtectCallToEventDelegatesAnalyzer_Message" xml:space="preserve">
        <value>The event '{0}' should be checked for null before invocation</value>
    </data>
    <data name="ProtectCallToEventDelegatesAnalyzer_Title" xml:space="preserve">
        <value>Protect call to event delegates</value>
    </data>
    <data name="ReplaceIncompleteOddnessCheck_Description" xml:space="preserve">
        <value>Using '(x % 2) == 1' to check for odd numbers will fail for negative numbers. Use '(x % 2 != 0)' or '(x &amp; 1 == 1)' instead.</value>
    </data>
    <data name="ReplaceIncompleteOddnessCheck_Message" xml:space="preserve">
        <value>The modulo operation used to check oddness may fail for negative numbers; consider using '(x % 2 != 0)' or '(x &amp; 1 == 1)'</value>
    </data>
    <data name="ReplaceIncompleteOddnessCheck_Title" xml:space="preserve">
        <value>Replace incomplete oddness check</value>
    </data>
    <data name="ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Description" xml:space="preserve">
        <value>Locks should be used only for operations on variables. Consider using Interlocked for atomic operations.</value>
    </data>
    <data name="ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Message" xml:space="preserve">
        <value>The lock on '{0}' should be reviewed to ensure it is necessary</value>
    </data>
    <data name="ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Title" xml:space="preserve">
        <value>Review lock used only for operations on variables</value>
    </data>
    <data name="ToStringShouldNotReturnNull_Description" xml:space="preserve">
        <value>Overridden ToString() methods should not return null. An appropriately descriptive string, or string.Empty, should be returned instead to make the value more useful.</value>
    </data>
    <data name="ToStringShouldNotReturnNull_Message" xml:space="preserve">
        <value>The ToString() method returns null; consider returning a descriptive string or string.Empty</value>
    </data>
    <data name="ToStringShouldNotReturnNull_Title" xml:space="preserve">
        <value>ToString() should not return null</value>
    </data>
    <data name="WriteStaticFieldFromInstanceMethod_Description" xml:space="preserve">
        <value>Writing to static fields from instance methods can cause issues in multithreaded environments. Consider refactoring to avoid this pattern.</value>
    </data>
    <data name="WriteStaticFieldFromInstanceMethod_Message" xml:space="preserve">
        <value>The instance method '{0}' writes to static field '{1}', which can cause issues in multithreaded environments</value>
    </data>
    <data name="WriteStaticFieldFromInstanceMethod_Title" xml:space="preserve">
        <value>Do not write to static fields from instance methods</value>
    </data>
    <data name="AttributeStringLiteralsShouldParseCorrectly_Description" xml:space="preserve">
        <value>This rule checks attributes with certain types (Version, Guid, Uri) and validates the string value.</value>
    </data>
    <data name="AttributeStringLiteralsShouldParseCorrectly_Message" xml:space="preserve">
        <value>String literal in attribute does not parse correctly: '{0}'</value>
    </data>
    <data name="AttributeStringLiteralsShouldParseCorrectly_Title" xml:space="preserve">
        <value>Attribute string literals should parse correctly</value>
    </data>
    <data name="AvoidConstructorsInStaticTypes_Description" xml:space="preserve">
        <value>This rule checks for types that contain only static members and fires if the type contains a visible instance constructor.</value>
    </data>
    <data name="AvoidConstructorsInStaticTypes_Message" xml:space="preserve">
        <value>Static type '{0}' contains a constructor</value>
    </data>
    <data name="AvoidConstructorsInStaticTypes_Title" xml:space="preserve">
        <value>Avoid constructors in static types</value>
    </data>
    <data name="AvoidFloatingPointEquality_Description" xml:space="preserve">
        <value>In general floating point numbers cannot be usefully compared using the equality and inequality operators.</value>
    </data>
    <data name="AvoidFloatingPointEquality_Message" xml:space="preserve">
        <value>Floating point comparison with equality operator may cause unexpected results</value>
    </data>
    <data name="AvoidFloatingPointEquality_Title" xml:space="preserve">
        <value>Avoid floating point equality comparison</value>
    </data>
    <data name="BadRecursiveInvocation_Description" xml:space="preserve">
        <value>This rule checks for methods that may be infinitely recursive.</value>
    </data>
    <data name="BadRecursiveInvocation_Message" xml:space="preserve">
        <value>Method '{0}' recursively calls itself</value>
    </data>
    <data name="BadRecursiveInvocation_Title" xml:space="preserve">
        <value>Avoid bad recursive invocation</value>
    </data>
    <data name="CallingEqualsWithNullArg_Description" xml:space="preserve">
        <value>This rule checks for methods that call Equals with a null actual parameter.</value>
    </data>
    <data name="CallingEqualsWithNullArg_Message" xml:space="preserve">
        <value>Method '{0}' calls Equals with a null argument</value>
    </data>
    <data name="CallingEqualsWithNullArg_Title" xml:space="preserve">
        <value>Avoid calling Equals with null argument</value>
    </data>
    <data name="CheckParametersNullityInVisibleMethods_Description" xml:space="preserve">
        <value>This rule checks if all nullable parameters of visible methods are compared with null before they get used.</value>
    </data>
    <data name="CheckParametersNullityInVisibleMethods_Message" xml:space="preserve">
        <value>Parameter '{0}' is not checked for null</value>
    </data>
    <data name="CheckParametersNullityInVisibleMethods_Title" xml:space="preserve">
        <value>Check nullable parameters for null before use</value>
    </data>
    <data name="DisposableFieldsShouldBeDisposed_Description" xml:space="preserve">
        <value>The rule inspects all fields for disposable types and checks that the type’s Dispose method calls Dispose on all disposable fields.</value>
    </data>
    <data name="DisposableFieldsShouldBeDisposed_Message" xml:space="preserve">
        <value>Field '{0}' is not disposed</value>
    </data>
    <data name="DisposableFieldsShouldBeDisposed_Title" xml:space="preserve">
        <value>Disposable fields should be disposed</value>
    </data>
    <data name="DoNotCompareWithNaN_Description" xml:space="preserve">
        <value>As defined in IEEE 754 it’s impossible to compare any floating-point value, even another NaN, with NaN.</value>
    </data>
    <data name="DoNotCompareWithNaN_Message" xml:space="preserve">
        <value>Comparison with NaN always returns false</value>
    </data>
    <data name="DoNotCompareWithNaN_Title" xml:space="preserve">
        <value>Do not compare with NaN</value>
    </data>
    <data name="DoNotRecurseInEquality_Description" xml:space="preserve">
        <value>An equality operator (==) orinequality operator (!=) method is calling itself recursively.</value>
    </data>
    <data name="DoNotRecurseInEquality_Message" xml:space="preserve">
        <value>Equality operator calls itself recursively</value>
    </data>
    <data name="DoNotRecurseInEquality_Title" xml:space="preserve">
        <value>Do not recurse in equality operator</value>
    </data>
    <data name="DoNotRoundIntegers_Description" xml:space="preserve">
        <value>This rule checks for attempts to call Round, Ceiling, Floor or Truncate on an integral type.</value>
    </data>
    <data name="DoNotRoundIntegers_Message" xml:space="preserve">
        <value>Rounding operation on an integer is redundant</value>
    </data>
    <data name="DoNotRoundIntegers_Title" xml:space="preserve">
        <value>Do not round integers</value>
    </data>
    <data name="EnsureLocalDisposal_Description" xml:space="preserve">
        <value>This rule checks that disposable locals are always disposed of before the method returns.</value>
    </data>
    <data name="EnsureLocalDisposal_Message" xml:space="preserve">
        <value>Local disposable object '{0}' is not disposed</value>
    </data>
    <data name="EnsureLocalDisposal_Title" xml:space="preserve">
        <value>Ensure local disposal</value>
    </data>
    <data name="FinalizersShouldCallBaseClassFinalizer_Description" xml:space="preserve">
        <value>This rule checks that a finalizer calls the base class finalizer.</value>
    </data>
    <data name="FinalizersShouldCallBaseClassFinalizer_Message" xml:space="preserve">
        <value>Finalizer does not call the base class finalizer</value>
    </data>
    <data name="FinalizersShouldCallBaseClassFinalizer_Title" xml:space="preserve">
        <value>Finalizers should call base class finalizer</value>
    </data>
    <data name="MethodCanBeMadeStatic_Description" xml:space="preserve">
        <value>This rule checks for methods that do not require anything from the current instance and can be converted into static methods.</value>
    </data>
    <data name="MethodCanBeMadeStatic_Message" xml:space="preserve">
        <value>Method '{0}' can be made static</value>
    </data>
    <data name="MethodCanBeMadeStatic_Title" xml:space="preserve">
        <value>Method can be made static</value>
    </data>
    <data name="ProvideCorrectArgumentsToFormattingMethods_Description" xml:space="preserve">
        <value>This rule checks that the format string used with String.Format matches the other parameters used with the method.</value>
    </data>
    <data name="ProvideCorrectArgumentsToFormattingMethods_Message" xml:space="preserve">
        <value>The format string in '{0}' does not match the arguments provided</value>
    </data>
    <data name="ProvideCorrectArgumentsToFormattingMethods_Title" xml:space="preserve">
        <value>Provide correct arguments to formatting methods</value>
    </data>
    <data name="ProvideCorrectRegexPattern_Description" xml:space="preserve">
        <value>This rule verifies that valid regular expression strings are used as arguments.</value>
    </data>
    <data name="ProvideCorrectRegexPattern_Message" xml:space="preserve">
        <value>Invalid regex pattern in '{0}'</value>
    </data>
    <data name="ProvideCorrectRegexPattern_Title" xml:space="preserve">
        <value>Provide correct regex pattern</value>
    </data>
    <data name="ProvideValidXmlString_Description" xml:space="preserve">
        <value>This rule verifies that valid XML string arguments are passed as arguments.</value>
    </data>
    <data name="ProvideValidXmlString_Message" xml:space="preserve">
        <value>Invalid XML string in '{0}'</value>
    </data>
    <data name="ProvideValidXmlString_Title" xml:space="preserve">
        <value>Provide valid XML string</value>
    </data>
    <data name="ProvideValidXPathExpression_Description" xml:space="preserve">
        <value>This rule verifies that valid XPath expression strings are passed as arguments.</value>
    </data>
    <data name="ProvideValidXPathExpression_Message" xml:space="preserve">
        <value>Invalid XPath expression in '{0}'</value>
    </data>
    <data name="ProvideValidXPathExpression_Title" xml:space="preserve">
        <value>Provide valid XPath expression</value>
    </data>
    <data name="ReviewCastOnIntegerDivision_Description" xml:space="preserve">
        <value>This rule checks for integral divisions where the result is cast to a floating point type.</value>
    </data>
    <data name="ReviewCastOnIntegerDivision_Message" xml:space="preserve">
        <value>Cast on integer division may cause truncation</value>
    </data>
    <data name="ReviewCastOnIntegerDivision_Title" xml:space="preserve">
        <value>Review cast on integer division</value>
    </data>
    <data name="ReviewCastOnIntegerMultiplication_Description" xml:space="preserve">
        <value>This rule checks for integral multiply operations where the result is cast to a larger integral type.</value>
    </data>
    <data name="ReviewCastOnIntegerMultiplication_Message" xml:space="preserve">
        <value>Cast on integer multiplication may cause overflow</value>
    </data>
    <data name="ReviewCastOnIntegerMultiplication_Title" xml:space="preserve">
        <value>Review cast on integer multiplication</value>
    </data>
    <data name="ReviewDoubleAssignment_Description" xml:space="preserve">
        <value>This rule checks for variables or fields that are assigned multiple times using the same value.</value>
    </data>
    <data name="ReviewDoubleAssignment_Message" xml:space="preserve">
        <value>Variable '{0}' is assigned twice with the same value</value>
    </data>
    <data name="ReviewDoubleAssignment_Title" xml:space="preserve">
        <value>Review double assignment</value>
    </data>
    <data name="ReviewInconsistentIdentity_Description" xml:space="preserve">
        <value>This rule checks to see if a type manages its identity in a consistent way.</value>
    </data>
    <data name="ReviewInconsistentIdentity_Message" xml:space="preserve">
        <value>Identity management for '{0}' is inconsistent</value>
    </data>
    <data name="ReviewInconsistentIdentity_Title" xml:space="preserve">
        <value>Review inconsistent identity management</value>
    </data>
    <data name="ReviewSelfAssignment_Description" xml:space="preserve">
        <value>This rule checks for variables or fields that are assigned to themselves.</value>
    </data>
    <data name="ReviewSelfAssignment_Message" xml:space="preserve">
        <value>Variable '{0}' is assigned to itself</value>
    </data>
    <data name="ReviewSelfAssignment_Title" xml:space="preserve">
        <value>Review self-assignment</value>
    </data>
    <data name="ReviewUselessControlFlow_Description" xml:space="preserve">
        <value>This rule checks for empty blocks that produce useless control flow inside IL.</value>
    </data>
    <data name="ReviewUselessControlFlow_Message" xml:space="preserve">
        <value>Useless control flow detected</value>
    </data>
    <data name="ReviewUselessControlFlow_Title" xml:space="preserve">
        <value>Review useless control flow</value>
    </data>
    <data name="ReviewUseOfInt64BitsToDouble_Description" xml:space="preserve">
        <value>This rule checks for invalid integer to double conversion using BitConverter.Int64BitsToDouble method.</value>
    </data>
    <data name="ReviewUseOfInt64BitsToDouble_Message" xml:space="preserve">
        <value>Invalid use of BitConverter.Int64BitsToDouble</value>
    </data>
    <data name="ReviewUseOfInt64BitsToDouble_Title" xml:space="preserve">
        <value>Review use of Int64BitsToDouble</value>
    </data>
    <data name="ReviewUseOfModuloOneOnIntegers_Description" xml:space="preserve">
        <value>This rule checks for a modulo one operation on an integral type.</value>
    </data>
    <data name="ReviewUseOfModuloOneOnIntegers_Message" xml:space="preserve">
        <value>Modulo one operation on an integer is likely a typo</value>
    </data>
    <data name="ReviewUseOfModuloOneOnIntegers_Title" xml:space="preserve">
        <value>Review use of modulo one on integers</value>
    </data>
    <data name="UseValueInPropertySetter_Description" xml:space="preserve">
        <value>Use value in property setter</value>
    </data>
    <data name="UseValueInPropertySetter_Message" xml:space="preserve">
        <value>Property setter does not use 'value'</value>
    </data>
    <data name="UseValueInPropertySetter_Title" xml:space="preserve">
        <value>This rule ensures all setter properties uses the value argument passed to the property.</value>
    </data>
    <data name="AvoidExtensionMethodOnSystemObject_Title" xml:space="preserve">
        <value>Avoid extension method on System.Object</value>
    </data>
    <data name="AvoidExtensionMethodOnSystemObject_Message" xml:space="preserve">
        <value>Extension method '{0}' should not be defined on System.Object</value>
    </data>
    <data name="AvoidExtensionMethodOnSystemObject_Description" xml:space="preserve">
        <value>Extension methods should not be used to extend System.Object. Such extension methods cannot be consumed by some languages, like VB.NET, which use late-binding on System.Object instances.</value>
    </data>
    <data name="AvoidMethodWithUnusedGenericType_Title" xml:space="preserve">
        <value>Avoid Method with unused generic-type parameter</value>
    </data>
    <data name="AvoidMethodWithUnusedGenericType_Message" xml:space="preserve">
        <value>Generic type parameter '{0}' is not used in method parameters</value>
    </data>
    <data name="AvoidMethodWithUnusedGenericType_Description" xml:space="preserve">
        <value>Unused generic type parameters can be removed</value>
    </data>
    <data name="AvoidMethodWithUnusedGenericTypeAnalyzer_Title" xml:space="preserve">
        <value>Avoid Method with Unused Generic Type Parameter</value>
    </data>
    <data name="AvoidMethodWithUnusedGenericTypeAnalyzer_Message" xml:space="preserve">
        <value>Generic type parameter '{0}' is not used in method parameters</value>
    </data>
    <data name="AvoidMethodWithUnusedGenericTypeAnalyzer_Description" xml:space="preserve">
        <value>Unused generic types should be utilized in method parameters or removed to improve code clarity.</value>
    </data>
    <data name="DoNotExposeNestedGenericSignatures_Title" xml:space="preserve">
        <value>Do Not Expose Nested Generic Signatures</value>
    </data>
    <data name="DoNotExposeNestedGenericSignatures_Message" xml:space="preserve">
        <value>Method '{0}' exposes a nested generic signature</value>
    </data>
    <data name="DoNotExposeNestedGenericSignatures_Description" xml:space="preserve">
        <value>Nested generic signatures should be avoided for publicly exposed methods, as they can be difficult to construct and understand.</value>
    </data>
    <data name="ImplementGenericCollectionInterfaces_Title" xml:space="preserve">
        <value>Implement Generic Collection Interfaces</value>
    </data>
    <data name="ImplementGenericCollectionInterfaces_Message" xml:space="preserve">
        <value>Consider implementing 'IEnumerable&lt;T&gt;' instead of 'IEnumerable' for type safety and improved usability</value>
    </data>
    <data name="ImplementGenericCollectionInterfaces_Description" xml:space="preserve">
        <value>Implementing 'IEnumerable&lt;T&gt;' helps avoid type casting and ensures type safety during iteration.</value>
    </data>
    <data name="PreferGenericsOverRefObject_Title" xml:space="preserve">
        <value>Prefer Generics Over Ref Object</value>
    </data>
    <data name="PreferGenericsOverRefObject_Message" xml:space="preserve">
        <value>Avoid using 'ref object', prefer using generics for type safety</value>
    </data>
    <data name="PreferGenericsOverRefObject_Description" xml:space="preserve">
        <value>Using generics instead of 'ref object' provides type safety and a more intuitive API for consumers.</value>
    </data>
    <data name="UseGenericEventHandler_Title" xml:space="preserve">
        <value>Use Generic EventHandler&lt;TEventArgs&gt;</value>
    </data>
    <data name="UseGenericEventHandler_Message" xml:space="preserve">
        <value>Use 'EventHandler&lt;TEventArgs&gt;' instead of custom delegate types</value>
    </data>
    <data name="UseGenericEventHandler_Description" xml:space="preserve">
        <value>Replacing custom delegate types with 'EventHandler&lt;TEventArgs&gt;' improves consistency and leverages built-in .NET patterns.</value>
    </data>
    <data name="AvoidArgumentExceptionDefaultConstructorTitle" xml:space="preserve">
        <value>Avoid using default constructor for {0}</value>
    </data>
    <data name="AvoidArgumentExceptionDefaultConstructorMessage" xml:space="preserve">
        <value>Use of default constructor for {0} is discouraged; provide parameter name and message</value>
    </data>
    <data name="AvoidArgumentExceptionDefaultConstructorDescription" xml:space="preserve">
        <value>Ensure that exceptions derived from ArgumentException provide meaningful parameter names and messages</value>
    </data>
    <data name="DoNotDestroyStackTraceTitle" xml:space="preserve">
        <value>Do not destroy stack trace when rethrowing exceptions</value>
    </data>
    <data name="DoNotDestroyStackTraceMessage" xml:space="preserve">
        <value>Use 'throw;' instead of 'throw ex;' to preserve stack trace</value>
    </data>
    <data name="DoNotDestroyStackTraceDescription" xml:space="preserve">
        <value>Rethrowing exceptions using 'throw ex;' resets the stack trace. Use 'throw;' to preserve it.</value>
    </data>
    <data name="DoNotSwallowErrorsCatchingNonSpecificExceptionsTitle" xml:space="preserve">
        <value>Avoid swallowing exceptions by catching non-specific exceptions</value>
    </data>
    <data name="DoNotSwallowErrorsCatchingNonSpecificExceptionsMessage" xml:space="preserve">
        <value>Catching non-specific exceptions without rethrowing can swallow errors</value>
    </data>
    <data name="DoNotSwallowErrorsCatchingNonSpecificExceptionsDescription" xml:space="preserve">
        <value>Catch specific exceptions or rethrow to avoid swallowing errors</value>
    </data>
    <data name="DoNotThrowReservedExceptionTitle" xml:space="preserve">
        <value>Avoid throwing reserved exceptions</value>
    </data>
    <data name="DoNotThrowReservedExceptionMessage" xml:space="preserve">
        <value>Do not throw '{0}'; it is reserved for use by the runtime</value>
    </data>
    <data name="DoNotThrowReservedExceptionDescription" xml:space="preserve">
        <value>Throwing reserved exceptions can cause unexpected behavior; use appropriate exception types</value>
    </data>
    <data name="ExceptionShouldBeVisibleTitle" xml:space="preserve">
        <value>Exception types should be public</value>
    </data>
    <data name="ExceptionShouldBeVisibleMessage" xml:space="preserve">
        <value>Exception type '{0}' should be public to be meaningful to API consumers</value>
    </data>
    <data name="ExceptionShouldBeVisibleDescription" xml:space="preserve">
        <value>Non-public exception types derived directly from basic exceptions do not provide sufficient information to consumers</value>
    </data>
    <data name="InstantiateArgumentExceptionCorrectlyTitle" xml:space="preserve">
        <value>Instantiate argument exceptions correctly</value>
    </data>
    <data name="InstantiateArgumentExceptionCorrectlyMessage" xml:space="preserve">
        <value>Parameters to '{0}' constructor are in the wrong order</value>
    </data>
    <data name="InstantiateArgumentExceptionCorrectlyDescription" xml:space="preserve">
        <value>Ensure that the parameter name and message are provided in the correct order when throwing argument exceptions.</value>
    </data>
    <data name="UseObjectDisposedExceptionTitle" xml:space="preserve">
        <value>Throw ObjectDisposedException when disposed object is accessed</value>
    </data>
    <data name="UseObjectDisposedExceptionMessage" xml:space="preserve">
        <value>Method '{0}' should throw ObjectDisposedException if object is disposed</value>
    </data>
    <data name="UseObjectDisposedExceptionDescription" xml:space="preserve">
        <value>Public methods should check if the object is disposed and throw ObjectDisposedException if it is</value>
    </data>
    <data name="AvoidThrowingBasicExceptionsTitle" xml:space="preserve">
        <value>Avoid throwing basic exceptions</value>
      </data>
    <data name="AvoidThrowingBasicExceptionsMessage" xml:space="preserve">
    <value>Avoid throwing basic exception type '{0}'; throw a more specific exception instead</value>
  </data>
    <data name="AvoidThrowingBasicExceptionsDescription" xml:space="preserve">
    <value>Throwing basic exceptions like System.Exception, System.ApplicationException, or System.SystemException does not provide enough information about the error to be helpful to the consumer of the library</value>
  </data>
  <data name="MissingExceptionConstructorsTitle" xml:space="preserve">
    <value>Exception types should implement standard exception constructors</value>
  </data>
  <data name="MissingExceptionConstructorsMessage" xml:space="preserve">
    <value>Exception type '{0}' is missing one or more required constructors</value>
  </data>
  <data name="MissingExceptionConstructorsDescription" xml:space="preserve">
    <value>Ensure that exception types implement the standard exception constructors for proper serialization and usage.</value>
  </data>
  <data name="DoNotThrowInUnexpectedLocationTitle" xml:space="preserve">
    <value>Avoid throwing exceptions in unexpected locations</value>
  </data>
  <data name="DoNotThrowInUnexpectedLocationMessage" xml:space="preserve">
    <value>Do not throw exceptions in method '{0}' as it is unexpected</value>
  </data>
  <data name="DoNotThrowInUnexpectedLocationDescription" xml:space="preserve">
    <value>Methods like Equals, GetHashCode, ToString, Dispose, and finalizers should not throw exceptions</value>
  </data>
  <data name="AbstractTypesShouldNotHavePublicConstructorsTitle" xml:space="preserve">
    <value>Abstract types should not have public constructors</value>
  </data>
  <data name="AbstractTypesShouldNotHavePublicConstructorsMessage" xml:space="preserve">
    <value>Abstract type '{0}' has a public constructor. Consider changing it to protected to clarify the type's intended usage.</value>
  </data>
  <data name="AbstractTypesShouldNotHavePublicConstructorsDescription" xml:space="preserve">
    <value>Abstract types should not expose public constructors as they can only be instantiated by derived types. A protected constructor is more appropriate for these cases.</value>
  </data>
    <data name="DelegatesPassedToNativeCodeMustIncludeExceptionHandlingTitle" xml:space="preserve">
    <value>Delegate passed to native code must include exception handling</value>
  </data>
  <data name="DelegatesPassedToNativeCodeMustIncludeExceptionHandlingMessage" xml:space="preserve">
    <value>Method '{0}' is used as a delegate passed to native code and must include a try-catch block that spans the entire method</value>
  </data>
  <data name="DelegatesPassedToNativeCodeMustIncludeExceptionHandlingDescription" xml:space="preserve">
    <value>Delegates passed to native code must handle exceptions to prevent unhandled exceptions from propagating into unmanaged code.</value>
  </data>
  <data name="DoNotAssumeIntPtrSizeTitle" xml:space="preserve">
    <value>Do not assume IntPtr size</value>
  </data>
  <data name="DoNotAssumeIntPtrSizeMessage" xml:space="preserve">
    <value>Casting IntPtr to a 32-bit or smaller type can cause errors on 64-bit platforms</value>
  </data>
  <data name="DoNotAssumeIntPtrSizeDescription" xml:space="preserve">
    <value>Avoid casting IntPtr or UIntPtr to 32-bit or smaller types; use Int64 or avoid casting to integer types.</value>
  </data>
  <data name="GetLastErrorMustBeCalledRightAfterPInvokeTitle" xml:space="preserve">
    <value>GetLastWin32Error must be called immediately after P/Invoke</value>
  </data>
  <data name="GetLastErrorMustBeCalledRightAfterPInvokeMessage" xml:space="preserve">
    <value>Marshal.GetLastWin32Error should be called immediately after a P/Invoke call to avoid overwriting the error code</value>
  </data>
  <data name="GetLastErrorMustBeCalledRightAfterPInvokeDescription" xml:space="preserve">
    <value>Calling other managed methods before GetLastWin32Error may overwrite the error code.</value>
  </data>
  <data name="MarshalBooleansInPInvokeDeclarationsTitle" xml:space="preserve">
    <value>Booleans in P/Invoke signatures should be explicitly marshaled</value>
  </data>
  <data name="MarshalBooleansInPInvokeDeclarationsMessage" xml:space="preserve">
    <value>Boolean parameter '{0}' in P/Invoke should have an explicit [MarshalAs] attribute</value>
  </data>
  <data name="MarshalBooleansInPInvokeDeclarationsDescription" xml:space="preserve">
    <value>Specify the [MarshalAs] attribute for boolean parameters in P/Invoke declarations to ensure correct size across platforms.</value>
  </data>
  <data name="MarshalStringsInPInvokeDeclarationsTitle" xml:space="preserve">
    <value>Strings in P/Invoke signatures should specify CharSet or [MarshalAs]</value>
  </data>
  <data name="MarshalStringsInPInvokeDeclarationsMessage" xml:space="preserve">
    <value>String parameter '{0}' in P/Invoke should specify CharSet in DllImport or have an explicit [MarshalAs] attribute</value>
  </data>
  <data name="MarshalStringsInPInvokeDeclarationsDescription" xml:space="preserve">
    <value>Specify the CharSet in DllImport or use [MarshalAs] for string parameters in P/Invoke declarations to ensure correct string marshaling across platforms</value>
  </data>
  <data name="PInvokeShouldNotBeVisibleTitle" xml:space="preserve">
    <value>P/Invoke methods should not be publicly visible</value>
  </data>
  <data name="PInvokeShouldNotBeVisibleMessage" xml:space="preserve">
    <value>P/Invoke method '{0}' should not be public or protected; consider making it internal</value>
  </data>
  <data name="PInvokeShouldNotBeVisibleDescription" xml:space="preserve">
    <value>Making P/Invoke methods internal helps encapsulate native code dependencies and reduces the public API surface</value>
  </data>
  <data name="UseManagedAlternativesToPInvokeTitle" xml:space="preserve">
    <value>Use managed alternatives to P/Invoke methods</value>
  </data>
  <data name="UseManagedAlternativesToPInvokeMessage" xml:space="preserve">
    <value>Use managed alternative '{1}' instead of P/Invoke method '{0}'</value>
  </data>
  <data name="UseManagedAlternativesToPInvokeDescription" xml:space="preserve">
    <value>Using managed alternatives improves portability and maintainability of code.</value>
  </data>
    <data name="AvoidAlwaysNullFieldTitle" xml:space="preserve">
    <value>Avoid fields that are always null</value>
  </data>
    <data name="AvoidAlwaysNullFieldMessage" xml:space="preserve">
    <value>Field '{0}' is always null and is never assigned a value</value>
  </data>
    <data name="AvoidAlwaysNullFieldDescription" xml:space="preserve">
    <value>Fields that are never assigned a value and remain null can lead to NullReferenceExceptions and should be initialized or removed if unnecessary</value>
  </data>
    <data name="AvoidComplexMethodsTitle" xml:space="preserve">
    <value>Avoid complex methods</value>
  </data>
    <data name="AvoidComplexMethodsMessage" xml:space="preserve">
    <value>Method '{0}' has a cyclomatic complexity of {1}, which is higher than the allowed threshold</value>
  </data>
    <data name="AvoidComplexMethodsDescription" xml:space="preserve">
    <value>Methods with high cyclomatic complexity are difficult to understand and maintain. Consider refactoring to reduce complexity.</value>
  </data>
    <data name="AvoidDeepInheritanceTreeTitle" xml:space="preserve">
    <value>Avoid deep inheritance trees</value>
  </data>
    <data name="AvoidDeepInheritanceTreeMessage" xml:space="preserve">
    <value>Type '{0}' has an inheritance depth of {1}, which exceeds the maximum allowed depth</value>
  </data>
    <data name="AvoidDeepInheritanceTreeDescription" xml:space="preserve">
    <value>Deep inheritance hierarchies can make code difficult to understand and maintain. Consider refactoring to reduce inheritance depth.</value>
  </data>
    <data name="AvoidLackOfCohesionOfMethodsTitle" xml:space="preserve">
    <value>Avoid types with low cohesion</value>
  </data>
    <data name="AvoidLackOfCohesionOfMethodsMessage" xml:space="preserve">
    <value>Type '{0}' has a lack of cohesion value of {1}, indicating low cohesion</value>
  </data>
    <data name="AvoidLackOfCohesionOfMethodsDescription" xml:space="preserve">
    <value>Types with low cohesion are often doing too many unrelated things, making them hard to understand and maintain. Consider refactoring.</value>
  </data>
    <data name="AvoidUnnecessarySpecializationTitle" xml:space="preserve">
    <value>Avoid unnecessary specialization in method parameters</value>
  </data>
    <data name="AvoidUnnecessarySpecializationMessage" xml:space="preserve">
    <value>Parameter '{0}' can be of a more general type '{1}'</value>
  </data>
    <data name="AvoidUnnecessarySpecializationDescription" xml:space="preserve">
    <value>Using unnecessarily specialized parameter types reduces method reusability. Consider using more general types or interfaces.</value>
  </data>
    <data name="ConsiderUsingStopwatchTitle" xml:space="preserve">
    <value>Consider using Stopwatch instead of DateTime for timing</value>
  </data>
    <data name="ConsiderUsingStopwatchMessage" xml:space="preserve">
    <value>Consider using System.Diagnostics.Stopwatch instead of DateTime.Now for measuring elapsed time</value>
  </data>
    <data name="ConsiderUsingStopwatchDescription" xml:space="preserve">
    <value>Stopwatch provides more accurate timing and better expresses the intent of measuring elapsed time.</value>
  </data>
    <data name="PreferStringIsNullOrEmptyTitle" xml:space="preserve">
    <value>Prefer String.IsNullOrEmpty over manual checks</value>
  </data>
    <data name="PreferStringIsNullOrEmptyMessage" xml:space="preserve">
    <value>Use String.IsNullOrEmpty instead of separate null and length checks</value>
  </data>
    <data name="PreferStringIsNullOrEmptyDescription" xml:space="preserve">
    <value>Using String.IsNullOrEmpty improves code readability and clarity over manual null and length checks.</value>
  </data>
</root>