<?xml version="1.0" encoding="utf-8"?>
<root>
    <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
        <xsd:element name="root" msdata:IsDataSet="true">
        </xsd:element>
    </xsd:schema>
    <resheader name="resmimetype">
        <value>text/microsoft-resx</value>
    </resheader>
    <resheader name="version">
        <value>1.3</value>
    </resheader>
    <resheader name="reader">
        <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral,
            PublicKeyToken=b77a5c561934e089
        </value>
    </resheader>
    <resheader name="writer">
        <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral,
            PublicKeyToken=b77a5c561934e089
        </value>
    </resheader>
    <data name="AssemblyVersionMismatch_Description" xml:space="preserve">
        <value>All assembly version attributes should be consistent.</value>
    </data>
    <data name="AssemblyVersionMismatch_HelpLink" xml:space="preserve">
        <value>https://www.mono-project.com/docs/tools+libraries/tools/gendarme/rules/bad-practice/#avoidassemblyversionmismatchrule</value>
    </data>
    <data name="AssemblyVersionMismatch_Message" xml:space="preserve">
        <value>Assembly version '{0}' does not match other version attributes</value>
    </data>
    <data name="AssemblyVersionMismatch_Title" xml:space="preserve">
        <value>Assembly version mismatch</value>
    </data>
    <data name="AvoidCallingProblematicMethods_Description" xml:space="preserve">
        <value>Avoid using methods that are known to be problematic due to potential issues such as performance problems or incorrect behavior.</value>
    </data>
    <data name="AvoidCallingProblematicMethods_Message" xml:space="preserve">
        <value>Method '{0}' is considered problematic.</value>
    </data>
    <data name="AvoidCallingProblematicMethods_Title" xml:space="preserve">
        <value>Avoid problematic methods</value>
    </data>
    <data name="AvoidVisibleConstantField_Description" xml:space="preserve">
        <value>Avoid constant fields which are visible outside the current assembly. Use 'static readonly' instead.</value>
    </data>
    <data name="AvoidVisibleConstantField_Message" xml:space="preserve">
        <value>The constant field '{0}' is visible outside the assembly</value>
    </data>
    <data name="AvoidVisibleConstantField_Title" xml:space="preserve">
        <value>Avoid visible constant field</value>
    </data>
    <data name="CheckNewExceptionWithoutThrowing_Description" xml:space="preserve">
        <value>Exception objects should be thrown, returned, or passed to another method as an argument.</value>
    </data>
    <data name="CheckNewExceptionWithoutThrowing_Message" xml:space="preserve">
        <value>The exception '{0}' is created but not thrown, not returned, and not passed to another method</value>
    </data>
    <data name="CheckNewExceptionWithoutThrowing_Title" xml:space="preserve">
        <value>Exception object created but not thrown or used</value>
    </data>
    <data name="CheckNewThreadWithoutStart_Description" xml:space="preserve">
        <value>Thread objects should be started, returned, or passed to another method as an argument.</value>
    </data>
    <data name="CheckNewThreadWithoutStart_Message" xml:space="preserve">
        <value>The thread '{0}' is created but not started, not returned, and not passed to another method</value>
    </data>
    <data name="CheckNewThreadWithoutStart_Title" xml:space="preserve">
        <value>Thread object created but not started or used</value>
    </data>
    <data name="CloneMethodShouldNotReturnNull_Description" xml:space="preserve">
        <value>Clone methods should not return null. They should return a new object instance.</value>
    </data>
    <data name="CloneMethodShouldNotReturnNull_Message" xml:space="preserve">
        <value>The Clone method returns null</value>
    </data>
    <data name="CloneMethodShouldNotReturnNull_Title" xml:space="preserve">
        <value>Clone method should not return null</value>
    </data>
    <data name="ConstructorShouldNotCallVirtualMethods_Description" xml:space="preserve">
        <value>Constructors of non-sealed types should not call virtual methods. This can lead to fragile code if the method is overridden in a derived class.</value>
    </data>
    <data name="ConstructorShouldNotCallVirtualMethods_Message" xml:space="preserve">
        <value>The constructor calls the virtual method '{0}'</value>
    </data>
    <data name="ConstructorShouldNotCallVirtualMethods_Title" xml:space="preserve">
        <value>Constructor should not call virtual methods</value>
    </data>
    <data name="DisableDebuggingCode_Description" xml:space="preserve">
        <value>Non-console applications should not contain calls to Console.WriteLine. Use Debug.WriteLine or Conditional(\"DEBUG\") instead.</value>
    </data>
    <data name="DisableDebuggingCode_Message" xml:space="preserve">
        <value>The method '{0}' contains a call to Console.WriteLine</value>
    </data>
    <data name="DisableDebuggingCode_Title" xml:space="preserve">
        <value>Disable debugging code in non-console applications</value>
    </data>
    <data name="DoNotForgetNotImplementedMethods_Description" xml:space="preserve">
        <value>Methods throwing NotImplementedException should be implemented before release.</value>
    </data>
    <data name="DoNotForgetNotImplementedMethods_Message" xml:space="preserve">
        <value>The method '{0}' throws a NotImplementedException</value>
    </data>
    <data name="DoNotForgetNotImplementedMethods_Title" xml:space="preserve">
        <value>Do not forget NotImplemented methods</value>
    </data>
    <data name="DoNotLockOnThisOrTypesAnalyzer_Description" xml:space="preserve">
        <value>Using 'lock (this)' or 'lock (typeof(...))' can cause deadlocks. Use a private lock object instead.</value>
    </data>
    <data name="DoNotLockOnThisOrTypesAnalyzer_Message" xml:space="preserve">
        <value>Do not lock on 'this' or 'Type' to avoid deadlocks</value>
    </data>
    <data name="DoNotLockOnThisOrTypesAnalyzer_Title" xml:space="preserve">
        <value>Do not lock on 'this' or 'Type'</value>
    </data>
    <data name="DoNotLockOnWeakIdentityObjectsAnalyzer_Description" xml:space="preserve">
        <value>Locking on objects with weak identity (e.g., strings, exceptions) can cause deadlocks. Use a private lock object instead.</value>
    </data>
    <data name="DoNotLockOnWeakIdentityObjectsAnalyzer_Message" xml:space="preserve">
        <value>Do not lock on objects with weak identity to avoid deadlocks</value>
    </data>
    <data name="DoNotLockOnWeakIdentityObjectsAnalyzer_Title" xml:space="preserve">
        <value>Do not lock on objects with weak identity</value>
    </data>
    <data name="DoNotUseEnumIsAssignableFrom_Description" xml:space="preserve">
        <value>Calls to typeof(Enum).IsAssignableFrom(type) can be simplified to type.IsEnum.</value>
    </data>
    <data name="DoNotUseEnumIsAssignableFrom_Message" xml:space="preserve">
        <value>Replace 'typeof(Enum).IsAssignableFrom({0})' with '{0}.IsEnum'</value>
    </data>
    <data name="DoNotUseEnumIsAssignableFrom_Title" xml:space="preserve">
        <value>Use type.IsEnum instead of typeof(Enum).IsAssignableFrom(type)</value>
    </data>
    <data name="DoNotUseLockedRegionOutsideMethodAnalyzer_Description" xml:space="preserve">
        <value>Using Monitor.Enter without Monitor.Exit in the same method can lead to deadlocks and is difficult to maintain.</value>
    </data>
    <data name="DoNotUseLockedRegionOutsideMethodAnalyzer_Message" xml:space="preserve">
        <value>Do not use Monitor.Enter without corresponding Monitor.Exit in the same method</value>
    </data>
    <data name="DoNotUseLockedRegionOutsideMethodAnalyzer_Title" xml:space="preserve">
        <value>Do not use locked region outside method</value>
    </data>
    <data name="DoNotUseMethodImplOptionsSynchronizedAnalyzer_Description" xml:space="preserve">
        <value>Using MethodImplOptions.Synchronized causes a lock(this) or lock(typeof(...)) which can cause deadlocks. Use a private lock object instead.</value>
    </data>
    <data name="DoNotUseMethodImplOptionsSynchronizedAnalyzer_Message" xml:space="preserve">
        <value>Do not use MethodImplOptions.Synchronized on method '{0}'</value>
    </data>
    <data name="DoNotUseMethodImplOptionsSynchronizedAnalyzer_Title" xml:space="preserve">
        <value>Do not use MethodImplOptions.Synchronized</value>
    </data>
    <data name="DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Description" xml:space="preserve">
        <value>The ThreadStatic attribute can only be applied to static fields. Applying it to instance fields is ineffective.</value>
    </data>
    <data name="DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Message" xml:space="preserve">
        <value>The field '{0}' is an instance field with the ThreadStatic attribute, which is ineffective</value>
    </data>
    <data name="DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Title" xml:space="preserve">
        <value>Do not use ThreadStatic attribute with instance fields</value>
    </data>
    <data name="DoubleCheckLockingAnalyzer_Description" xml:space="preserve">
        <value>Double-check locking can be problematic in older versions of .NET. Ensure it is used correctly.</value>
    </data>
    <data name="DoubleCheckLockingAnalyzer_Message" xml:space="preserve">
        <value>Avoid double-check locking on '{0}'</value>
    </data>
    <data name="DoubleCheckLockingAnalyzer_Title" xml:space="preserve">
        <value>Avoid double-check locking</value>
    </data>
    <data name="EqualsShouldHandleNullArg_Description" xml:space="preserve">
        <value>Equals(object) methods should return false when the object parameter is null.</value>
    </data>
    <data name="EqualsShouldHandleNullArg_Message" xml:space="preserve">
        <value>Equals method does not handle null argument</value>
    </data>
    <data name="EqualsShouldHandleNullArg_Title" xml:space="preserve">
        <value>Equals method should handle null argument</value>
    </data>
    <data name="GetEntryAssemblyMayReturnNull_Description" xml:space="preserve">
        <value>Calls to Assembly.GetEntryAssembly() may return null in libraries or DLLs. Ensure proper null handling.</value>
    </data>
    <data name="GetEntryAssemblyMayReturnNull_Message" xml:space="preserve">
        <value>Assembly.GetEntryAssembly may return null when called from a library or DLL</value>
    </data>
    <data name="GetEntryAssemblyMayReturnNull_Title" xml:space="preserve">
        <value>Assembly.GetEntryAssembly may return null</value>
    </data>
    <data name="NonConstantStaticFieldsShouldNotBeVisible_Description" xml:space="preserve">
        <value>Public static fields should be constant or readonly to avoid synchronization issues.</value>
    </data>
    <data name="NonConstantStaticFieldsShouldNotBeVisible_Message" xml:space="preserve">
        <value>The static field '{0}' should not be publicly visible</value>
    </data>
    <data name="NonConstantStaticFieldsShouldNotBeVisible_Title" xml:space="preserve">
        <value>Non-constant static fields should not be visible</value>
    </data>
    <data name="ObsoleteMessagesShouldNotBeEmpty_Description" xml:space="preserve">
        <value>The Obsolete attribute is more helpful if it includes advice on how to deal with the situation (e.g., the new recommended API to use).</value>
    </data>
    <data name="ObsoleteMessagesShouldNotBeEmpty_Message" xml:space="preserve">
        <value>The Obsolete attribute on '{0}' should include a message providing guidance.</value>
    </data>
    <data name="ObsoleteMessagesShouldNotBeEmpty_Title" xml:space="preserve">
        <value>Obsolete attribute should not be empty</value>
    </data>
    <data name="OnlyUseDisposeForIDisposableTypes_Description" xml:space="preserve">
        <value>Methods named Dispose should be reserved for types that implement IDisposable to avoid confusing developers.</value>
    </data>
    <data name="OnlyUseDisposeForIDisposableTypes_Message" xml:space="preserve">
        <value>The method '{0}' is named Dispose but the containing type does not implement IDisposable</value>
    </data>
    <data name="OnlyUseDisposeForIDisposableTypes_Title" xml:space="preserve">
        <value>Methods named Dispose should be reserved for types that implement IDisposable</value>
    </data>
    <data name="PreferEmptyInstanceOverNull_Description" xml:space="preserve">
        <value>Methods and properties which return a string, an array, a collection, or an enumerable should return an empty instance rather than null.</value>
    </data>
    <data name="PreferEmptyInstanceOverNull_Message" xml:space="preserve">
        <value>The method or property '{0}' returns null; consider returning an empty instance instead</value>
    </data>
    <data name="PreferEmptyInstanceOverNull_Title" xml:space="preserve">
        <value>Prefer returning an empty instance over null</value>
    </data>
    <data name="PreferSafeHandle_Description" xml:space="preserve">
        <value>It is recommended to use SafeHandle instead of IntPtr or UIntPtr for handling unmanaged resources.</value>
    </data>
    <data name="PreferSafeHandle_Message" xml:space="preserve">
        <value>Consider using SafeHandle instead of {0} for better resource management and safety</value>
    </data>
    <data name="PreferSafeHandle_Title" xml:space="preserve">
        <value>Prefer SafeHandle over IntPtr or UIntPtr for unmanaged resources</value>
    </data>
    <data name="ProtectCallToEventDelegatesAnalyzer_Description" xml:space="preserve">
        <value>Event delegates should be checked for null and copied to a local variable to avoid race conditions.</value>
    </data>
    <data name="ProtectCallToEventDelegatesAnalyzer_Message" xml:space="preserve">
        <value>The event '{0}' should be checked for null before invocation</value>
    </data>
    <data name="ProtectCallToEventDelegatesAnalyzer_Title" xml:space="preserve">
        <value>Protect call to event delegates</value>
    </data>
    <data name="ReplaceIncompleteOddnessCheck_Description" xml:space="preserve">
        <value>Using '(x % 2) == 1' to check for odd numbers will fail for negative numbers. Use '(x % 2 != 0)' or '(x &amp; 1 == 1)' instead.</value>
    </data>
    <data name="ReplaceIncompleteOddnessCheck_Message" xml:space="preserve">
        <value>The modulo operation used to check oddness may fail for negative numbers; consider using '(x % 2 != 0)' or '(x &amp; 1 == 1)'</value>
    </data>
    <data name="ReplaceIncompleteOddnessCheck_Title" xml:space="preserve">
        <value>Replace incomplete oddness check</value>
    </data>
    <data name="ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Description" xml:space="preserve">
        <value>Locks should be used only for operations on variables. Consider using Interlocked for atomic operations.</value>
    </data>
    <data name="ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Message" xml:space="preserve">
        <value>The lock on '{0}' should be reviewed to ensure it is necessary</value>
    </data>
    <data name="ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Title" xml:space="preserve">
        <value>Review lock used only for operations on variables</value>
    </data>
    <data name="ToStringShouldNotReturnNull_Description" xml:space="preserve">
        <value>Overridden ToString() methods should not return null. An appropriately descriptive string, or string.Empty, should be returned instead to make the value more useful.</value>
    </data>
    <data name="ToStringShouldNotReturnNull_Message" xml:space="preserve">
        <value>The ToString() method returns null; consider returning a descriptive string or string.Empty</value>
    </data>
    <data name="ToStringShouldNotReturnNull_Title" xml:space="preserve">
        <value>ToString() should not return null</value>
    </data>
    <data name="WriteStaticFieldFromInstanceMethod_Description" xml:space="preserve">
        <value>Writing to static fields from instance methods can cause issues in multithreaded environments. Consider refactoring to avoid this pattern.</value>
    </data>
    <data name="WriteStaticFieldFromInstanceMethod_Message" xml:space="preserve">
        <value>The instance method '{0}' writes to static field '{1}', which can cause issues in multithreaded environments</value>
    </data>
    <data name="WriteStaticFieldFromInstanceMethod_Title" xml:space="preserve">
        <value>Do not write to static fields from instance methods</value>
    </data>
    <data name="AttributeStringLiteralsShouldParseCorrectly_Description" xml:space="preserve">
        <value>This rule checks attributes with certain types (Version, Guid, Uri) and validates the string value.</value>
    </data>
    <data name="AttributeStringLiteralsShouldParseCorrectly_Message" xml:space="preserve">
        <value>String literal in attribute does not parse correctly: '{0}'</value>
    </data>
    <data name="AttributeStringLiteralsShouldParseCorrectly_Title" xml:space="preserve">
        <value>Attribute string literals should parse correctly</value>
    </data>
    <data name="AvoidConstructorsInStaticTypes_Description" xml:space="preserve">
        <value>This rule checks for types that contain only static members and fires if the type contains a visible instance constructor.</value>
    </data>
    <data name="AvoidConstructorsInStaticTypes_Message" xml:space="preserve">
        <value>Static type '{0}' contains a constructor</value>
    </data>
    <data name="AvoidConstructorsInStaticTypes_Title" xml:space="preserve">
        <value>Avoid constructors in static types</value>
    </data>
    <data name="AvoidFloatingPointEquality_Description" xml:space="preserve">
        <value>In general floating point numbers cannot be usefully compared using the equality and inequality operators.</value>
    </data>
    <data name="AvoidFloatingPointEquality_Message" xml:space="preserve">
        <value>Floating point comparison with equality operator may cause unexpected results</value>
    </data>
    <data name="AvoidFloatingPointEquality_Title" xml:space="preserve">
        <value>Avoid floating point equality comparison</value>
    </data>
    <data name="BadRecursiveInvocation_Description" xml:space="preserve">
        <value>This rule checks for methods that may be infinitely recursive.</value>
    </data>
    <data name="BadRecursiveInvocation_Message" xml:space="preserve">
        <value>Method '{0}' recursively calls itself</value>
    </data>
    <data name="BadRecursiveInvocation_Title" xml:space="preserve">
        <value>Avoid bad recursive invocation</value>
    </data>
    <data name="CallingEqualsWithNullArg_Description" xml:space="preserve">
        <value>This rule checks for methods that call Equals with a null actual parameter.</value>
    </data>
    <data name="CallingEqualsWithNullArg_Message" xml:space="preserve">
        <value>Method '{0}' calls Equals with a null argument</value>
    </data>
    <data name="CallingEqualsWithNullArg_Title" xml:space="preserve">
        <value>Avoid calling Equals with null argument</value>
    </data>
    <data name="CheckParametersNullityInVisibleMethods_Description" xml:space="preserve">
        <value>This rule checks if all nullable parameters of visible methods are compared with null before they get used.</value>
    </data>
    <data name="CheckParametersNullityInVisibleMethods_Message" xml:space="preserve">
        <value>Parameter '{0}' is not checked for null</value>
    </data>
    <data name="CheckParametersNullityInVisibleMethods_Title" xml:space="preserve">
        <value>Check nullable parameters for null before use</value>
    </data>
    <data name="DisposableFieldsShouldBeDisposed_Description" xml:space="preserve">
        <value>The rule inspects all fields for disposable types and checks that the type’s Dispose method calls Dispose on all disposable fields.</value>
    </data>
    <data name="DisposableFieldsShouldBeDisposed_Message" xml:space="preserve">
        <value>Field '{0}' is not disposed</value>
    </data>
    <data name="DisposableFieldsShouldBeDisposed_Title" xml:space="preserve">
        <value>Disposable fields should be disposed</value>
    </data>
    <data name="DoNotCompareWithNaN_Description" xml:space="preserve">
        <value>As defined in IEEE 754 it’s impossible to compare any floating-point value, even another NaN, with NaN.</value>
    </data>
    <data name="DoNotCompareWithNaN_Message" xml:space="preserve">
        <value>Comparison with NaN always returns false</value>
    </data>
    <data name="DoNotCompareWithNaN_Title" xml:space="preserve">
        <value>Do not compare with NaN</value>
    </data>
    <data name="DoNotRecurseInEquality_Description" xml:space="preserve">
        <value>An equality operator (==) orinequality operator (!=) method is calling itself recursively.</value>
    </data>
    <data name="DoNotRecurseInEquality_Message" xml:space="preserve">
        <value>Equality operator calls itself recursively</value>
    </data>
    <data name="DoNotRecurseInEquality_Title" xml:space="preserve">
        <value>Do not recurse in equality operator</value>
    </data>
    <data name="DoNotRoundIntegers_Description" xml:space="preserve">
        <value>This rule checks for attempts to call Round, Ceiling, Floor or Truncate on an integral type.</value>
    </data>
    <data name="DoNotRoundIntegers_Message" xml:space="preserve">
        <value>Rounding operation on an integer is redundant</value>
    </data>
    <data name="DoNotRoundIntegers_Title" xml:space="preserve">
        <value>Do not round integers</value>
    </data>
    <data name="EnsureLocalDisposal_Description" xml:space="preserve">
        <value>This rule checks that disposable locals are always disposed of before the method returns.</value>
    </data>
    <data name="EnsureLocalDisposal_Message" xml:space="preserve">
        <value>Local disposable object '{0}' is not disposed</value>
    </data>
    <data name="EnsureLocalDisposal_Title" xml:space="preserve">
        <value>Ensure local disposal</value>
    </data>
    <data name="FinalizersShouldCallBaseClassFinalizer_Description" xml:space="preserve">
        <value>This rule checks that a finalizer calls the base class finalizer.</value>
    </data>
    <data name="FinalizersShouldCallBaseClassFinalizer_Message" xml:space="preserve">
        <value>Finalizer does not call the base class finalizer</value>
    </data>
    <data name="FinalizersShouldCallBaseClassFinalizer_Title" xml:space="preserve">
        <value>Finalizers should call base class finalizer</value>
    </data>
    <data name="MethodCanBeMadeStatic_Description" xml:space="preserve">
        <value>This rule checks for methods that do not require anything from the current instance and can be converted into static methods.</value>
    </data>
    <data name="MethodCanBeMadeStatic_Message" xml:space="preserve">
        <value>Method '{0}' can be made static</value>
    </data>
    <data name="MethodCanBeMadeStatic_Title" xml:space="preserve">
        <value>Method can be made static</value>
    </data>
    <data name="ProvideCorrectArgumentsToFormattingMethods_Description" xml:space="preserve">
        <value>This rule checks that the format string used with String.Format matches the other parameters used with the method.</value>
    </data>
    <data name="ProvideCorrectArgumentsToFormattingMethods_Message" xml:space="preserve">
        <value>The format string in '{0}' does not match the arguments provided</value>
    </data>
    <data name="ProvideCorrectArgumentsToFormattingMethods_Title" xml:space="preserve">
        <value>Provide correct arguments to formatting methods</value>
    </data>
    <data name="ProvideCorrectRegexPattern_Description" xml:space="preserve">
        <value>This rule verifies that valid regular expression strings are used as arguments.</value>
    </data>
    <data name="ProvideCorrectRegexPattern_Message" xml:space="preserve">
        <value>Invalid regex pattern in '{0}'</value>
    </data>
    <data name="ProvideCorrectRegexPattern_Title" xml:space="preserve">
        <value>Provide correct regex pattern</value>
    </data>
    <data name="ProvideValidXmlString_Description" xml:space="preserve">
        <value>This rule verifies that valid XML string arguments are passed as arguments.</value>
    </data>
    <data name="ProvideValidXmlString_Message" xml:space="preserve">
        <value>Invalid XML string in '{0}'</value>
    </data>
    <data name="ProvideValidXmlString_Title" xml:space="preserve">
        <value>Provide valid XML string</value>
    </data>
    <data name="ProvideValidXPathExpression_Description" xml:space="preserve">
        <value>This rule verifies that valid XPath expression strings are passed as arguments.</value>
    </data>
    <data name="ProvideValidXPathExpression_Message" xml:space="preserve">
        <value>Invalid XPath expression in '{0}'</value>
    </data>
    <data name="ProvideValidXPathExpression_Title" xml:space="preserve">
        <value>Provide valid XPath expression</value>
    </data>
    <data name="ReviewCastOnIntegerDivision_Description" xml:space="preserve">
        <value>This rule checks for integral divisions where the result is cast to a floating point type.</value>
    </data>
    <data name="ReviewCastOnIntegerDivision_Message" xml:space="preserve">
        <value>Cast on integer division may cause truncation</value>
    </data>
    <data name="ReviewCastOnIntegerDivision_Title" xml:space="preserve">
        <value>Review cast on integer division</value>
    </data>
    <data name="ReviewCastOnIntegerMultiplication_Description" xml:space="preserve">
        <value>This rule checks for integral multiply operations where the result is cast to a larger integral type.</value>
    </data>
    <data name="ReviewCastOnIntegerMultiplication_Message" xml:space="preserve">
        <value>Cast on integer multiplication may cause overflow</value>
    </data>
    <data name="ReviewCastOnIntegerMultiplication_Title" xml:space="preserve">
        <value>Review cast on integer multiplication</value>
    </data>
    <data name="ReviewDoubleAssignment_Description" xml:space="preserve">
        <value>This rule checks for variables or fields that are assigned multiple times using the same value.</value>
    </data>
    <data name="ReviewDoubleAssignment_Message" xml:space="preserve">
        <value>Variable '{0}' is assigned twice with the same value</value>
    </data>
    <data name="ReviewDoubleAssignment_Title" xml:space="preserve">
        <value>Review double assignment</value>
    </data>
    <data name="ReviewInconsistentIdentity_Description" xml:space="preserve">
        <value>This rule checks to see if a type manages its identity in a consistent way.</value>
    </data>
    <data name="ReviewInconsistentIdentity_Message" xml:space="preserve">
        <value>Identity management for '{0}' is inconsistent</value>
    </data>
    <data name="ReviewInconsistentIdentity_Title" xml:space="preserve">
        <value>Review inconsistent identity management</value>
    </data>
    <data name="ReviewSelfAssignment_Description" xml:space="preserve">
        <value>This rule checks for variables or fields that are assigned to themselves.</value>
    </data>
    <data name="ReviewSelfAssignment_Message" xml:space="preserve">
        <value>Variable '{0}' is assigned to itself</value>
    </data>
    <data name="ReviewSelfAssignment_Title" xml:space="preserve">
        <value>Review self-assignment</value>
    </data>
    <data name="ReviewUselessControlFlow_Description" xml:space="preserve">
        <value>This rule checks for empty blocks that produce useless control flow inside IL.</value>
    </data>
    <data name="ReviewUselessControlFlow_Message" xml:space="preserve">
        <value>Useless control flow detected</value>
    </data>
    <data name="ReviewUselessControlFlow_Title" xml:space="preserve">
        <value>Review useless control flow</value>
    </data>
    <data name="ReviewUseOfInt64BitsToDouble_Description" xml:space="preserve">
        <value>This rule checks for invalid integer to double conversion using BitConverter.Int64BitsToDouble method.</value>
    </data>
    <data name="ReviewUseOfInt64BitsToDouble_Message" xml:space="preserve">
        <value>Invalid use of BitConverter.Int64BitsToDouble</value>
    </data>
    <data name="ReviewUseOfInt64BitsToDouble_Title" xml:space="preserve">
        <value>Review use of Int64BitsToDouble</value>
    </data>
    <data name="ReviewUseOfModuloOneOnIntegers_Description" xml:space="preserve">
        <value>This rule checks for a modulo one operation on an integral type.</value>
    </data>
    <data name="ReviewUseOfModuloOneOnIntegers_Message" xml:space="preserve">
        <value>Modulo one operation on an integer is likely a typo</value>
    </data>
    <data name="ReviewUseOfModuloOneOnIntegers_Title" xml:space="preserve">
        <value>Review use of modulo one on integers</value>
    </data>
    <data name="UseValueInPropertySetter_Description" xml:space="preserve">
        <value>Use value in property setter</value>
    </data>
    <data name="UseValueInPropertySetter_Message" xml:space="preserve">
        <value>Property setter does not use 'value'</value>
    </data>
    <data name="UseValueInPropertySetter_Title" xml:space="preserve">
        <value>This rule ensures all setter properties uses the value argument passed to the property.</value>
    </data>
    <data name="AvoidExtensionMethodOnSystemObject_Title" xml:space="preserve">
        <value>Avoid extension method on System.Object</value>
    </data>
    <data name="AvoidExtensionMethodOnSystemObject_Message" xml:space="preserve">
        <value>Extension method '{0}' should not be defined on System.Object</value>
    </data>
    <data name="AvoidExtensionMethodOnSystemObject_Description" xml:space="preserve">
        <value>Extension methods should not be used to extend System.Object. Such extension methods cannot be consumed by some languages, like VB.NET, which use late-binding on System.Object instances.</value>
    </data>
    <data name="AvoidMethodWithUnusedGenericType_Title" xml:space="preserve">
        <value>Avoid Method with unused generic-type parameter</value>
    </data>
    <data name="AvoidMethodWithUnusedGenericType_Message" xml:space="preserve">
        <value>Generic type parameter '{0}' is not used in method parameters</value>
    </data>
    <data name="AvoidMethodWithUnusedGenericType_Description" xml:space="preserve">
        <value>Unused generic type parameters can be removed</value>
    </data>
    <data name="AvoidMethodWithUnusedGenericTypeAnalyzer_Title" xml:space="preserve">
        <value>Avoid Method with Unused Generic Type Parameter</value>
    </data>
    <data name="AvoidMethodWithUnusedGenericTypeAnalyzer_Message" xml:space="preserve">
        <value>Generic type parameter '{0}' is not used in method parameters</value>
    </data>
    <data name="AvoidMethodWithUnusedGenericTypeAnalyzer_Description" xml:space="preserve">
        <value>Unused generic types should be utilized in method parameters or removed to improve code clarity.</value>
    </data>
    <data name="DoNotExposeNestedGenericSignatures_Title" xml:space="preserve">
        <value>Do Not Expose Nested Generic Signatures</value>
    </data>
    <data name="DoNotExposeNestedGenericSignatures_Message" xml:space="preserve">
        <value>Method '{0}' exposes a nested generic signature</value>
    </data>
    <data name="DoNotExposeNestedGenericSignatures_Description" xml:space="preserve">
        <value>Nested generic signatures should be avoided for publicly exposed methods, as they can be difficult to construct and understand.</value>
    </data>
    <data name="ImplementGenericCollectionInterfaces_Title" xml:space="preserve">
        <value>Implement Generic Collection Interfaces</value>
    </data>
    <data name="ImplementGenericCollectionInterfaces_Message" xml:space="preserve">
        <value>Consider implementing 'IEnumerable&lt;T&gt;' instead of 'IEnumerable' for type safety and improved usability</value>
    </data>
    <data name="ImplementGenericCollectionInterfaces_Description" xml:space="preserve">
        <value>Implementing 'IEnumerable&lt;T&gt;' helps avoid type casting and ensures type safety during iteration.</value>
    </data>
    <data name="PreferGenericsOverRefObject_Title" xml:space="preserve">
        <value>Prefer Generics Over Ref Object</value>
    </data>
    <data name="PreferGenericsOverRefObject_Message" xml:space="preserve">
        <value>Avoid using 'ref object', prefer using generics for type safety</value>
    </data>
    <data name="PreferGenericsOverRefObject_Description" xml:space="preserve">
        <value>Using generics instead of 'ref object' provides type safety and a more intuitive API for consumers.</value>
    </data>
    <data name="UseGenericEventHandler_Title" xml:space="preserve">
        <value>Use Generic EventHandler&lt;TEventArgs&gt;</value>
    </data>
    <data name="UseGenericEventHandler_Message" xml:space="preserve">
        <value>Use 'EventHandler&lt;TEventArgs&gt;' instead of custom delegate types</value>
    </data>
    <data name="UseGenericEventHandler_Description" xml:space="preserve">
        <value>Replacing custom delegate types with 'EventHandler&lt;TEventArgs&gt;' improves consistency and leverages built-in .NET patterns.</value>
    </data>
    <data name="AvoidArgumentExceptionDefaultConstructorTitle" xml:space="preserve">
        <value>Avoid using default constructor for {0}</value>
    </data>
    <data name="AvoidArgumentExceptionDefaultConstructorMessage" xml:space="preserve">
        <value>Use of default constructor for {0} is discouraged; provide parameter name and message</value>
    </data>
    <data name="AvoidArgumentExceptionDefaultConstructorDescription" xml:space="preserve">
        <value>Ensure that exceptions derived from ArgumentException provide meaningful parameter names and messages</value>
    </data>
    <data name="DoNotDestroyStackTraceTitle" xml:space="preserve">
        <value>Do not destroy stack trace when rethrowing exceptions</value>
    </data>
    <data name="DoNotDestroyStackTraceMessage" xml:space="preserve">
        <value>Use 'throw;' instead of 'throw ex;' to preserve stack trace</value>
    </data>
    <data name="DoNotDestroyStackTraceDescription" xml:space="preserve">
        <value>Rethrowing exceptions using 'throw ex;' resets the stack trace. Use 'throw;' to preserve it.</value>
    </data>
    <data name="DoNotSwallowErrorsCatchingNonSpecificExceptionsTitle" xml:space="preserve">
        <value>Avoid swallowing exceptions by catching non-specific exceptions</value>
    </data>
    <data name="DoNotSwallowErrorsCatchingNonSpecificExceptionsMessage" xml:space="preserve">
        <value>Catching non-specific exceptions without rethrowing can swallow errors</value>
    </data>
    <data name="DoNotSwallowErrorsCatchingNonSpecificExceptionsDescription" xml:space="preserve">
        <value>Catch specific exceptions or rethrow to avoid swallowing errors</value>
    </data>
    <data name="DoNotThrowReservedExceptionTitle" xml:space="preserve">
        <value>Avoid throwing reserved exceptions</value>
    </data>
    <data name="DoNotThrowReservedExceptionMessage" xml:space="preserve">
        <value>Do not throw '{0}'; it is reserved for use by the runtime</value>
    </data>
    <data name="DoNotThrowReservedExceptionDescription" xml:space="preserve">
        <value>Throwing reserved exceptions can cause unexpected behavior; use appropriate exception types</value>
    </data>
    <data name="ExceptionShouldBeVisibleTitle" xml:space="preserve">
        <value>Exception types should be public</value>
    </data>
    <data name="ExceptionShouldBeVisibleMessage" xml:space="preserve">
        <value>Exception type '{0}' should be public to be meaningful to API consumers</value>
    </data>
    <data name="ExceptionShouldBeVisibleDescription" xml:space="preserve">
        <value>Non-public exception types derived directly from basic exceptions do not provide sufficient information to consumers</value>
    </data>
    <data name="InstantiateArgumentExceptionCorrectlyTitle" xml:space="preserve">
        <value>Instantiate argument exceptions correctly</value>
    </data>
    <data name="InstantiateArgumentExceptionCorrectlyMessage" xml:space="preserve">
        <value>Parameters to '{0}' constructor are in the wrong order</value>
    </data>
    <data name="InstantiateArgumentExceptionCorrectlyDescription" xml:space="preserve">
        <value>Ensure that the parameter name and message are provided in the correct order when throwing argument exceptions.</value>
    </data>
    <data name="UseObjectDisposedExceptionTitle" xml:space="preserve">
        <value>Throw ObjectDisposedException when disposed object is accessed</value>
    </data>
    <data name="UseObjectDisposedExceptionMessage" xml:space="preserve">
        <value>Method '{0}' should throw ObjectDisposedException if object is disposed</value>
    </data>
    <data name="UseObjectDisposedExceptionDescription" xml:space="preserve">
        <value>Public methods should check if the object is disposed and throw ObjectDisposedException if it is</value>
    </data>
    <data name="AvoidThrowingBasicExceptionsTitle" xml:space="preserve">
        <value>Avoid throwing basic exceptions</value>
      </data>
    <data name="AvoidThrowingBasicExceptionsMessage" xml:space="preserve">
    <value>Avoid throwing basic exception type '{0}'; throw a more specific exception instead</value>
  </data>
    <data name="AvoidThrowingBasicExceptionsDescription" xml:space="preserve">
    <value>Throwing basic exceptions like System.Exception, System.ApplicationException, or System.SystemException does not provide enough information about the error to be helpful to the consumer of the library</value>
  </data>
  <data name="MissingExceptionConstructorsTitle" xml:space="preserve">
    <value>Exception types should implement standard exception constructors</value>
  </data>
  <data name="MissingExceptionConstructorsMessage" xml:space="preserve">
    <value>Exception type '{0}' is missing one or more required constructors</value>
  </data>
  <data name="MissingExceptionConstructorsDescription" xml:space="preserve">
    <value>Ensure that exception types implement the standard exception constructors for proper serialization and usage.</value>
  </data>
  <data name="DoNotThrowInUnexpectedLocationTitle" xml:space="preserve">
    <value>Avoid throwing exceptions in unexpected locations</value>
  </data>
  <data name="DoNotThrowInUnexpectedLocationMessage" xml:space="preserve">
    <value>Do not throw exceptions in method '{0}' as it is unexpected</value>
  </data>
  <data name="DoNotThrowInUnexpectedLocationDescription" xml:space="preserve">
    <value>Methods like Equals, GetHashCode, ToString, Dispose, and finalizers should not throw exceptions</value>
  </data>
  <data name="AbstractTypesShouldNotHavePublicConstructorsTitle" xml:space="preserve">
    <value>Abstract types should not have public constructors</value>
  </data>
  <data name="AbstractTypesShouldNotHavePublicConstructorsMessage" xml:space="preserve">
    <value>Abstract type '{0}' has a public constructor. Consider changing it to protected to clarify the type's intended usage.</value>
  </data>
  <data name="AbstractTypesShouldNotHavePublicConstructorsDescription" xml:space="preserve">
    <value>Abstract types should not expose public constructors as they can only be instantiated by derived types. A protected constructor is more appropriate for these cases.</value>
  </data>
    <data name="DelegatesPassedToNativeCodeMustIncludeExceptionHandlingTitle" xml:space="preserve">
    <value>Delegate passed to native code must include exception handling</value>
  </data>
  <data name="DelegatesPassedToNativeCodeMustIncludeExceptionHandlingMessage" xml:space="preserve">
    <value>Method '{0}' is used as a delegate passed to native code and must include a try-catch block that spans the entire method</value>
  </data>
  <data name="DelegatesPassedToNativeCodeMustIncludeExceptionHandlingDescription" xml:space="preserve">
    <value>Delegates passed to native code must handle exceptions to prevent unhandled exceptions from propagating into unmanaged code.</value>
  </data>
  <data name="DoNotAssumeIntPtrSizeTitle" xml:space="preserve">
    <value>Do not assume IntPtr size</value>
  </data>
  <data name="DoNotAssumeIntPtrSizeMessage" xml:space="preserve">
    <value>Casting IntPtr to a 32-bit or smaller type can cause errors on 64-bit platforms</value>
  </data>
  <data name="DoNotAssumeIntPtrSizeDescription" xml:space="preserve">
    <value>Avoid casting IntPtr or UIntPtr to 32-bit or smaller types; use Int64 or avoid casting to integer types.</value>
  </data>
  <data name="GetLastErrorMustBeCalledRightAfterPInvokeTitle" xml:space="preserve">
    <value>GetLastWin32Error must be called immediately after P/Invoke</value>
  </data>
  <data name="GetLastErrorMustBeCalledRightAfterPInvokeMessage" xml:space="preserve">
    <value>Marshal.GetLastWin32Error should be called immediately after a P/Invoke call to avoid overwriting the error code</value>
  </data>
  <data name="GetLastErrorMustBeCalledRightAfterPInvokeDescription" xml:space="preserve">
    <value>Calling other managed methods before GetLastWin32Error may overwrite the error code.</value>
  </data>
  <data name="MarshalBooleansInPInvokeDeclarationsTitle" xml:space="preserve">
    <value>Booleans in P/Invoke signatures should be explicitly marshaled</value>
  </data>
  <data name="MarshalBooleansInPInvokeDeclarationsMessage" xml:space="preserve">
    <value>Boolean parameter '{0}' in P/Invoke should have an explicit [MarshalAs] attribute</value>
  </data>
  <data name="MarshalBooleansInPInvokeDeclarationsDescription" xml:space="preserve">
    <value>Specify the [MarshalAs] attribute for boolean parameters in P/Invoke declarations to ensure correct size across platforms.</value>
  </data>
  <data name="MarshalStringsInPInvokeDeclarationsTitle" xml:space="preserve">
    <value>Strings in P/Invoke signatures should specify CharSet or [MarshalAs]</value>
  </data>
  <data name="MarshalStringsInPInvokeDeclarationsMessage" xml:space="preserve">
    <value>String parameter '{0}' in P/Invoke should specify CharSet in DllImport or have an explicit [MarshalAs] attribute</value>
  </data>
  <data name="MarshalStringsInPInvokeDeclarationsDescription" xml:space="preserve">
    <value>Specify the CharSet in DllImport or use [MarshalAs] for string parameters in P/Invoke declarations to ensure correct string marshaling across platforms</value>
  </data>
  <data name="PInvokeShouldNotBeVisibleTitle" xml:space="preserve">
    <value>P/Invoke methods should not be publicly visible</value>
  </data>
  <data name="PInvokeShouldNotBeVisibleMessage" xml:space="preserve">
    <value>P/Invoke method '{0}' should not be public or protected; consider making it internal</value>
  </data>
  <data name="PInvokeShouldNotBeVisibleDescription" xml:space="preserve">
    <value>Making P/Invoke methods internal helps encapsulate native code dependencies and reduces the public API surface</value>
  </data>
  <data name="UseManagedAlternativesToPInvokeTitle" xml:space="preserve">
    <value>Use managed alternatives to P/Invoke methods</value>
  </data>
  <data name="UseManagedAlternativesToPInvokeMessage" xml:space="preserve">
    <value>Use managed alternative '{1}' instead of P/Invoke method '{0}'</value>
  </data>
  <data name="UseManagedAlternativesToPInvokeDescription" xml:space="preserve">
    <value>Using managed alternatives improves portability and maintainability of code.</value>
  </data>
    <data name="AvoidAlwaysNullFieldTitle" xml:space="preserve">
    <value>Avoid fields that are always null</value>
  </data>
    <data name="AvoidAlwaysNullFieldMessage" xml:space="preserve">
    <value>Field '{0}' is always null and is never assigned a value</value>
  </data>
    <data name="AvoidAlwaysNullFieldDescription" xml:space="preserve">
    <value>Fields that are never assigned a value and remain null can lead to NullReferenceExceptions and should be initialized or removed if unnecessary</value>
  </data>
    <data name="AvoidComplexMethodsTitle" xml:space="preserve">
    <value>Avoid complex methods</value>
  </data>
    <data name="AvoidComplexMethodsMessage" xml:space="preserve">
    <value>Method '{0}' has a cyclomatic complexity of {1}, which is higher than the allowed threshold</value>
  </data>
    <data name="AvoidComplexMethodsDescription" xml:space="preserve">
    <value>Methods with high cyclomatic complexity are difficult to understand and maintain. Consider refactoring to reduce complexity.</value>
  </data>
    <data name="AvoidDeepInheritanceTreeTitle" xml:space="preserve">
    <value>Avoid deep inheritance trees</value>
  </data>
    <data name="AvoidDeepInheritanceTreeMessage" xml:space="preserve">
    <value>Type '{0}' has an inheritance depth of {1}, which exceeds the maximum allowed depth</value>
  </data>
    <data name="AvoidDeepInheritanceTreeDescription" xml:space="preserve">
    <value>Deep inheritance hierarchies can make code difficult to understand and maintain. Consider refactoring to reduce inheritance depth.</value>
  </data>
    <data name="AvoidLackOfCohesionOfMethodsTitle" xml:space="preserve">
    <value>Avoid types with low cohesion</value>
  </data>
    <data name="AvoidLackOfCohesionOfMethodsMessage" xml:space="preserve">
    <value>Type '{0}' has a lack of cohesion value of {1}, indicating low cohesion</value>
  </data>
    <data name="AvoidLackOfCohesionOfMethodsDescription" xml:space="preserve">
    <value>Types with low cohesion are often doing too many unrelated things, making them hard to understand and maintain. Consider refactoring.</value>
  </data>
    <data name="AvoidUnnecessarySpecializationTitle" xml:space="preserve">
    <value>Avoid unnecessary specialization in method parameters</value>
  </data>
    <data name="AvoidUnnecessarySpecializationMessage" xml:space="preserve">
    <value>Parameter '{0}' can be of a more general type '{1}'</value>
  </data>
    <data name="AvoidUnnecessarySpecializationDescription" xml:space="preserve">
    <value>Using unnecessarily specialized parameter types reduces method reusability. Consider using more general types or interfaces.</value>
  </data>
    <data name="ConsiderUsingStopwatchTitle" xml:space="preserve">
    <value>Consider using Stopwatch instead of DateTime for timing</value>
  </data>
    <data name="ConsiderUsingStopwatchMessage" xml:space="preserve">
    <value>Consider using System.Diagnostics.Stopwatch instead of DateTime.Now for measuring elapsed time</value>
  </data>
    <data name="ConsiderUsingStopwatchDescription" xml:space="preserve">
    <value>Stopwatch provides more accurate timing and better expresses the intent of measuring elapsed time.</value>
  </data>
    <data name="PreferStringIsNullOrEmptyTitle" xml:space="preserve">
    <value>Prefer String.IsNullOrEmpty over manual checks</value>
  </data>
    <data name="PreferStringIsNullOrEmptyMessage" xml:space="preserve">
    <value>Use String.IsNullOrEmpty instead of separate null and length checks</value>
  </data>
    <data name="PreferStringIsNullOrEmptyDescription" xml:space="preserve">
    <value>Using String.IsNullOrEmpty improves code readability and clarity over manual null and length checks.</value>
  </data>
    <data name="AvoidDeepNamespaceHierarchyTitle" xml:space="preserve">
  <value>Avoid deep namespace hierarchy</value>
</data>
    <data name="AvoidDeepNamespaceHierarchyMessage" xml:space="preserve">
  <value>Namespace '{0}' has a depth of {1}, which exceeds the maximum allowed depth</value>
</data>
    <data name="AvoidDeepNamespaceHierarchyDescription" xml:space="preserve">
  <value>Deeply nested namespaces can make code harder to read and maintain. Consider refactoring to reduce the namespace depth.</value>
</data>
    <data name="AvoidNonAlphanumericIdentifierTitle" xml:space="preserve">
  <value>Avoid non-alphanumeric characters in identifiers</value>
</data>
    <data name="AvoidNonAlphanumericIdentifierMessage" xml:space="preserve">
  <value>Identifier '{0}' contains non-alphanumeric characters</value>
</data>
    <data name="AvoidNonAlphanumericIdentifierDescription" xml:space="preserve">
  <value>Identifiers should only contain alphanumeric characters to improve readability and maintain coding standards.</value>
</data>
    <data name="AvoidRedundancyInMethodNameTitle" xml:space="preserve">
  <value>Avoid redundancy in method names</value>
</data>
    <data name="AvoidRedundancyInMethodNameMessage" xml:space="preserve">
  <value>Method '{0}' embeds the type name of its first parameter '{1}'</value>
</data>
    <data name="AvoidRedundancyInMethodNameDescription" xml:space="preserve">
  <value>Removing the type name from the method name makes the API less verbose and easier to use.</value>
</data>
    <data name="AvoidRedundancyInTypeNameTitle" xml:space="preserve">
  <value>Avoid redundancy in type names</value>
</data>
    <data name="AvoidRedundancyInTypeNameMessage" xml:space="preserve">
  <value>Type '{0}' is prefixed with its namespace name '{1}'</value>
</data>
    <data name="AvoidRedundancyInTypeNameDescription" xml:space="preserve">
  <value>Removing redundant namespace prefixes from type names makes them less verbose and easier to use.</value>
</data>
    <data name="AvoidTypeInterfaceInconsistencyTitle" xml:space="preserve">
  <value>Avoid type/interface inconsistency</value>
</data>
    <data name="AvoidTypeInterfaceInconsistencyMessage" xml:space="preserve">
  <value>Type '{0}' does not implement the interface '{1}' with the same base name</value>
</data>
    <data name="AvoidTypeInterfaceInconsistencyDescription" xml:space="preserve">
  <value>If a type and an interface share the same base name, the type should implement the interface to meet expectations.</value>
</data>
    <data name="DoNotPrefixEventsWithAfterOrBeforeTitle" xml:space="preserve">
  <value>Do not prefix events with 'After' or 'Before'</value>
</data>
    <data name="DoNotPrefixEventsWithAfterOrBeforeMessage" xml:space="preserve">
  <value>Event '{0}' is prefixed with 'After' or 'Before'</value>
</data>
    <data name="DoNotPrefixEventsWithAfterOrBeforeDescription" xml:space="preserve">
  <value>Event names should use verbs in the present or past tense, not prefixes like 'After' or 'Before'.</value>
</data>
    <data name="DoNotPrefixValuesWithEnumNameTitle" xml:space="preserve">
  <value>Do not prefix enum values with enum type name</value>
</data>
    <data name="DoNotPrefixValuesWithEnumNameMessage" xml:space="preserve">
  <value>Enum value '{0}' is prefixed with its enum type name '{1}'</value>
</data>
    <data name="DoNotPrefixValuesWithEnumNameDescription" xml:space="preserve">
  <value>Enum values should not include the enum type name as a prefix to avoid redundancy.</value>
</data>
    <data name="DoNotUseReservedInEnumValueNamesTitle" xml:space="preserve">
  <value>Do not use 'Reserved' in enum value names</value>
</data>
    <data name="DoNotUseReservedInEnumValueNamesMessage" xml:space="preserve">
  <value>Enum '{1}' contains a value named '{0}', which should be avoided</value>
</data>
    <data name="DoNotUseReservedInEnumValueNamesDescription" xml:space="preserve">
  <value>Using 'Reserved' in enum values can lead to breaking changes when modifying the enum. It's better to add new meaningful values as needed.</value>
</data>
    <data name="ParameterNamesShouldMatchOverriddenMethodTitle" xml:space="preserve">
  <value>Parameter names should match overridden method</value>
</data>
    <data name="ParameterNamesShouldMatchOverriddenMethodMessage" xml:space="preserve">
  <value>Method '{0}' parameter '{1}' does not match parameter name '{2}' in overridden method</value>
</data>
    <data name="ParameterNamesShouldMatchOverriddenMethodDescription" xml:space="preserve">
  <value>Parameter names in overridden methods should match those in the base method to improve code clarity and usability.</value>
</data>
    <data name="UseCorrectCasingTitle" xml:space="preserve">
  <value>Use correct casing in identifiers</value>
</data>
    <data name="UseCorrectCasingMessage" xml:space="preserve">
  <value>{0} '{1}' does not follow correct casing convention</value>
</data>
    <data name="UseCorrectCasingDescription" xml:space="preserve">
  <value>Identifiers should follow .NET naming conventions for casing to improve readability and maintain consistency.</value>
</data>
    <data name="UseSingularNameInEnumsUnlessAreFlagsTitle" xml:space="preserve">
  <value>Use singular name in enums unless they are marked with [Flags]</value>
</data>
    <data name="UseSingularNameInEnumsUnlessAreFlagsMessage" xml:space="preserve">
  <value>Enum '{0}' should have a {1} name</value>
</data>
    <data name="UseSingularNameInEnumsUnlessAreFlagsDescription" xml:space="preserve">
  <value>Enums not marked with [Flags] should have singular names, while enums with [Flags] should have plural names.</value>
</data>
    <data name="UsePreferredTermsTitle" xml:space="preserve">
  <value>Use preferred terms in identifiers</value>
</data>
    <data name="UsePreferredTermsMessage" xml:space="preserve">
  <value>Identifier '{0}' contains '{1}', consider using '{2}' instead</value>
</data>
    <data name="UsePreferredTermsDescription" xml:space="preserve">
  <value>Use terms that are consistent with .NET Framework guidelines to improve code clarity and consistency.</value>
</data>
    <data name="UsePluralNameInEnumFlagsTitle" xml:space="preserve">
  <value>Use plural name for enums marked with [Flags]</value>
</data>
    <data name="UsePluralNameInEnumFlagsMessage" xml:space="preserve">
  <value>Enum '{0}' is marked with [Flags] but its name is not plural</value>
</data>
    <data name="UsePluralNameInEnumFlagsDescription" xml:space="preserve">
  <value>Enumerations decorated with [Flags] should have plural names to indicate that multiple values can be combined.</value>
</data>
    <data name="UseCorrectSuffixTitle" xml:space="preserve">
  <value>Use correct suffix in type names</value>
</data>
    <data name="UseCorrectSuffixMessage" xml:space="preserve">
  <value>{0}</value>
</data>
    <data name="UseCorrectSuffixDescription" xml:space="preserve">
  <value>Ensure that types have the correct suffix based on the base types or interfaces they inherit from or implement.</value>
</data>
    <data name="UseCorrectPrefixTitle" xml:space="preserve">
  <value>Use correct prefix in type names</value>
</data>
    <data name="UseCorrectPrefixMessage" xml:space="preserve">
  <value>{0} '{1}' {2}</value>
</data>
    <data name="UseCorrectPrefixDescription" xml:space="preserve">
  <value>Ensure that interfaces are prefixed with 'I', types are not prefixed with 'C', and generic parameters are correctly prefixed.</value>
</data>
    <data name="DoNotHardcodePathsTitle" xml:space="preserve">
  <value>Do not hardcode paths</value>
</data>
    <data name="DoNotHardcodePathsMessage" xml:space="preserve">
  <value>Avoid hardcoding paths in code; use Path.Combine or Environment.GetFolderPath instead</value>
</data>
    <data name="DoNotHardcodePathsDescription" xml:space="preserve">
  <value>Strings containing hardcoded paths are not portable across operating systems. Use Path.Combine and/or Environment.GetFolderPath to ensure cross-platform functionality.</value>
</data>

    <data name="ExitCodeIsLimitedOnUnixTitle" xml:space="preserve">
  <value>Limit exit codes to 0-255 on Unix</value>
</data>
    <data name="ExitCodeIsLimitedOnUnixMessage" xml:space="preserve">
  <value>Process exit codes must be between 0 and 255 on Unix systems</value>
</data>
    <data name="ExitCodeIsLimitedOnUnixDescription" xml:space="preserve">
  <value>On Unix systems, process exit codes must be between 0 and 255. Ensure that returned values and Environment.ExitCode are within this range.</value>
</data>

    <data name="FeatureRequiresRootPrivilegeOnUnixTitle" xml:space="preserve">
  <value>Feature requires root privilege on Unix</value>
</data>
    <data name="FeatureRequiresRootPrivilegeOnUnixMessage" xml:space="preserve">
  <value>This feature requires root privilege on Unix systems</value>
</data>
    <data name="FeatureRequiresRootPrivilegeOnUnixDescription" xml:space="preserve">
  <value>Certain features require root privilege on Unix systems. Ensure that code using such features handles privilege requirements appropriately.</value>
</data>

    <data name="MonoCompatibilityReviewTitle" xml:space="preserve">
  <value>Review Mono compatibility</value>
</data>
    <data name="MonoCompatibilityReviewMessage" xml:space="preserve">
  <value>This code may not be compatible with Mono</value>
</data>
    <data name="MonoCompatibilityReviewDescription" xml:space="preserve">
  <value>This code calls methods that are not fully implemented in Mono. Consider reviewing for Mono compatibility.</value>
</data>

    <data name="NewLineLiteralTitle" xml:space="preserve">
  <value>Do not use new line literals</value>
</data>
    <data name="NewLineLiteralMessage" xml:space="preserve">
  <value>Use Environment.NewLine instead of new line literals</value>
</data>
    <data name="NewLineLiteralDescription" xml:space="preserve">
  <value>Using literal '\n' or '\r' for new lines is not portable across operating systems. Use Environment.NewLine instead.</value>
</data>
    <data name="GtkSharpExecutableTargetTitle" xml:space="preserve">
  <value>Executable referencing GtkSharp should use Windows subsystem</value>
</data>
    <data name="GtkSharpExecutableTargetMessage" xml:space="preserve">
  <value>Executable assembly references GtkSharp but is not compiled with -target:winexe</value>
</data>
    <data name="GtkSharpExecutableTargetDescription" xml:space="preserve">
  <value>An executable assembly referencing GtkSharp should be compiled with -target:winexe to prevent a console window from appearing under Windows.</value>
</data>

    <data name="SystemWindowsFormsExecutableTargetTitle" xml:space="preserve">
  <value>Executable referencing System.Windows.Forms should use Windows subsystem</value>
</data>
    <data name="SystemWindowsFormsExecutableTargetMessage" xml:space="preserve">
  <value>Executable assembly references System.Windows.Forms but is not compiled with -target:winexe</value>
</data>
    <data name="SystemWindowsFormsExecutableTargetDescription" xml:space="preserve">
  <value>An executable assembly referencing System.Windows.Forms should be compiled with -target:winexe to prevent a console window from appearing under Windows.</value>
</data>

    <data name="UseSTAThreadAttributeOnSWFEntryPointsTitle" xml:space="preserve">
  <value>Use [STAThread] on Windows Forms entry points</value>
</data>
    <data name="UseSTAThreadAttributeOnSWFEntryPointsMessage" xml:space="preserve">
  <value>Entry point of Windows Forms application should be marked with [STAThread] attribute</value>
</data>
    <data name="UseSTAThreadAttributeOnSWFEntryPointsDescription" xml:space="preserve">
  <value>Windows Forms applications require the entry point method to be marked with [STAThread] attribute to function properly.</value>
</data>
    <data name="AvoidCodeDuplicatedInSameClassTitle" xml:space="preserve">
  <value>Avoid code duplication in the same class</value>
</data>
    <data name="AvoidCodeDuplicatedInSameClassMessage" xml:space="preserve">
  <value>Code is duplicated within the same class</value>
</data>
    <data name="AvoidCodeDuplicatedInSameClassDescription" xml:space="preserve">
  <value>Duplicated code within a class makes maintenance harder. Extract common code into methods to improve reusability and readability.</value>
</data>

    <data name="AvoidCodeDuplicatedInSiblingClassesTitle" xml:space="preserve">
  <value>Avoid code duplication in sibling classes</value>
</data>
    <data name="AvoidCodeDuplicatedInSiblingClassesMessage" xml:space="preserve">
  <value>Code is duplicated across sibling classes</value>
</data>
    <data name="AvoidCodeDuplicatedInSiblingClassesDescription" xml:space="preserve">
  <value>Duplicated code across sibling classes can lead to maintenance issues. Consider moving common code to a base class or utility class.</value>
</data>

    <data name="AvoidLargeClassesTitle" xml:space="preserve">
  <value>Avoid large classes</value>
</data>
    <data name="AvoidLargeClassesMessage" xml:space="preserve">
  <value>Class '{0}' is too large</value>
</data>
    <data name="AvoidLargeClassesDescription" xml:space="preserve">
  <value>Classes that are too large are harder to maintain. Consider splitting this class into smaller, more focused classes.</value>
</data>

    <data name="AvoidLongMethodsTitle" xml:space="preserve">
  <value>Avoid long methods</value>
</data>
    <data name="AvoidLongMethodsMessage" xml:space="preserve">
  <value>Method '{0}' is too long</value>
</data>
    <data name="AvoidLongMethodsDescription" xml:space="preserve">
  <value>Methods that are too long are harder to understand and maintain. Consider refactoring this method into smaller methods.</value>
</data>

    <data name="AvoidLongParameterListsTitle" xml:space="preserve">
  <value>Avoid long parameter lists</value>
</data>
    <data name="AvoidLongParameterListsMessage" xml:space="preserve">
  <value>Method '{0}' has too many parameters</value>
</data>
    <data name="AvoidLongParameterListsDescription" xml:space="preserve">
  <value>Methods with long parameter lists can be hard to use and maintain. Consider refactoring to reduce the number of parameters.</value>
</data>

    <data name="AvoidMessageChainsTitle" xml:space="preserve">
  <value>Avoid message chains</value>
</data>
    <data name="AvoidMessageChainsMessage" xml:space="preserve">
  <value>Message chain detected in method '{0}'</value>
</data>
    <data name="AvoidMessageChainsDescription" xml:space="preserve">
  <value>Long message chains indicate tight coupling to object navigation structures. Consider refactoring to reduce dependencies.</value>
</data>

    <data name="AvoidSpeculativeGeneralityTitle" xml:space="preserve">
  <value>Avoid speculative generality</value>
</data>
    <data name="AvoidSpeculativeGeneralityMessage" xml:space="preserve">
  <value>Speculative generality detected in '{0}'</value>
</data>
    <data name="AvoidSpeculativeGeneralityDescription" xml:space="preserve">
  <value>Unused abstractions or parameters may indicate speculative generality. Remove unnecessary code to improve clarity.</value>
</data>

    <data name="AvoidSwitchStatementsTitle" xml:space="preserve">
  <value>Avoid switch statements</value>
</data>
    <data name="AvoidSwitchStatementsMessage" xml:space="preserve">
  <value>Switch statement detected in method '{0}'</value>
</data>
    <data name="AvoidSwitchStatementsDescription" xml:space="preserve">
  <value>Switch statements can lead to duplicated code. Consider using polymorphism to achieve the same behavior.</value>
</data>

    <data name="CallBaseMethodsOnISerializableTypesTitle" xml:space="preserve">
  <value>Call base methods in ISerializable types</value>
</data>
    <data name="CallBaseMethodsOnISerializableTypesMessage" xml:space="preserve">
  <value>ISerializable type '{0}' does not call base {1} method</value>
</data>
    <data name="CallBaseMethodsOnISerializableTypesDescription" xml:space="preserve">
  <value>Types implementing ISerializable should call their base type's serialization constructor and GetObjectData method to ensure proper serialization.</value>
</data>

    <data name="DeserializeOptionalFieldTitle" xml:space="preserve">
  <value>Handle [OptionalField] during deserialization</value>
</data>
    <data name="DeserializeOptionalFieldMessage" xml:space="preserve">
  <value>Type '{0}' has [OptionalField] but no [OnDeserialized] or [OnDeserializing] method</value>
</data>
    <data name="DeserializeOptionalFieldDescription" xml:space="preserve">
  <value>Types with [OptionalField] should have methods decorated with [OnDeserialized] or [OnDeserializing] to properly initialize those fields during deserialization.</value>
</data>

    <data name="ImplementISerializableCorrectlyTitle" xml:space="preserve">
  <value>Implement ISerializable correctly</value>
</data>
    <data name="ImplementISerializableCorrectlyMessage" xml:space="preserve">
  <value>Type '{0}' does not implement ISerializable correctly</value>
</data>
    <data name="ImplementISerializableCorrectlyDescription" xml:space="preserve">
  <value>Types implementing ISerializable should serialize all instance fields not marked with [NonSerialized], and GetObjectData should be virtual if the type is not sealed.</value>
</data>

    <data name="MarkAllNonSerializableFieldsTitle" xml:space="preserve">
  <value>Mark all non-serializable fields with [NonSerialized]</value>
</data>
    <data name="MarkAllNonSerializableFieldsMessage" xml:space="preserve">
  <value>Field '{0}' in serializable type '{1}' is not serializable</value>
</data>
    <data name="MarkAllNonSerializableFieldsDescription" xml:space="preserve">
  <value>Fields of serializable types must be serializable or marked with [NonSerialized].</value>
</data>

    <data name="MarkEnumerationsAsSerializableTitle" xml:space="preserve">
  <value>Mark enumerations as [Serializable]</value>
</data>
    <data name="MarkEnumerationsAsSerializableMessage" xml:space="preserve">
  <value>Enum '{0}' is not marked as [Serializable]</value>
</data>
    <data name="MarkEnumerationsAsSerializableDescription" xml:space="preserve">
  <value>Even though enums are serializable by default, marking them with [Serializable] improves code readability.</value>
</data>

    <data name="MissingSerializableAttributeOnISerializableTypeTitle" xml:space="preserve">
  <value>Missing [Serializable] attribute on ISerializable type</value>
</data>
    <data name="MissingSerializableAttributeOnISerializableTypeMessage" xml:space="preserve">
  <value>Type '{0}' implements ISerializable but is not marked as [Serializable]</value>
</data>
    <data name="MissingSerializableAttributeOnISerializableTypeDescription" xml:space="preserve">
  <value>Types implementing ISerializable must be marked with the [Serializable] attribute to be serializable by the runtime.</value>
</data>

    <data name="MissingSerializationConstructorTitle" xml:space="preserve">
  <value>Missing serialization constructor</value>
</data>
    <data name="MissingSerializationConstructorMessage" xml:space="preserve">
  <value>Type '{0}' implements ISerializable but lacks the required serialization constructor</value>
</data>
    <data name="MissingSerializationConstructorDescription" xml:space="preserve">
  <value>Types implementing ISerializable must provide a serialization constructor with the correct signature.</value>
</data>

    <data name="UseCorrectSignatureForSerializationMethodsTitle" xml:space="preserve">
  <value>Use correct signature for serialization methods</value>
</data>
    <data name="UseCorrectSignatureForSerializationMethodsMessage" xml:space="preserve">
  <value>Method '{0}' has an incorrect signature for a serialization callback</value>
</data>
    <data name="UseCorrectSignatureForSerializationMethodsDescription" xml:space="preserve">
  <value>Methods decorated with serialization attributes should be private, return void, and have a single parameter of type StreamingContext.</value>
</data>
    <data name="ArrayFieldsShouldNotBeReadOnlyTitle" xml:space="preserve">
  <value>Array fields should not be public and readonly</value>
</data>
    <data name="ArrayFieldsShouldNotBeReadOnlyMessage" xml:space="preserve">
  <value>Public readonly array field '{0}' can be modified externally</value>
</data>
    <data name="ArrayFieldsShouldNotBeReadOnlyDescription" xml:space="preserve">
  <value>Marking a public array field as readonly only prevents the field from being assigned a different array instance. The array elements can still be modified. This can lead to unexpected behavior and security issues.</value>
</data>

    <data name="DoNotShortCircuitCertificateCheckTitle" xml:space="preserve">
  <value>Do not short-circuit certificate checks</value>
</data>
    <data name="DoNotShortCircuitCertificateCheckMessage" xml:space="preserve">
  <value>Certificate validation callback '{0}' should not unconditionally accept certificates</value>
</data>
    <data name="DoNotShortCircuitCertificateCheckDescription" xml:space="preserve">
  <value>Overriding certificate validation to accept all certificates disables critical security checks, making the application vulnerable to man-in-the-middle attacks.</value>
</data>

    <data name="NativeFieldsShouldNotBeVisibleTitle" xml:space="preserve">
  <value>Native fields should not be publicly visible</value>
</data>
    <data name="NativeFieldsShouldNotBeVisibleMessage" xml:space="preserve">
  <value>Field '{0}' is a publicly visible native field of type '{1}'</value>
</data>
    <data name="NativeFieldsShouldNotBeVisibleDescription" xml:space="preserve">
  <value>Exposing native fields publicly can lead to security and stability issues, as external code can modify or misuse these fields.</value>
</data>

    <data name="StaticConstructorsShouldBePrivateTitle" xml:space="preserve">
  <value>Static constructors should be private</value>
</data>
    <data name="StaticConstructorsShouldBePrivateMessage" xml:space="preserve">
  <value>Static constructor for type '{0}' is not private</value>
</data>
    <data name="StaticConstructorsShouldBePrivateDescription" xml:space="preserve">
  <value>Static constructors should be private to prevent external code from invoking them, which could lead to security vulnerabilities or unexpected behavior.</value>
</data>
    <data name="AddMissingTypeInheritanceDemandTitle" xml:space="preserve">
  <value>Add missing InheritanceDemand for unsealed types with LinkDemand</value>
</data>
    <data name="AddMissingTypeInheritanceDemandMessage" xml:space="preserve">
  <value>Type '{0}' is not sealed and has a LinkDemand but lacks an InheritanceDemand</value>
</data>
    <data name="AddMissingTypeInheritanceDemandDescription" xml:space="preserve">
  <value>Types that are not sealed and have a LinkDemand should also have an InheritanceDemand for the same permissions to prevent security issues arising from subclassing.</value>
</data>

    <data name="DoNotExposeFieldsInSecuredTypeTitle" xml:space="preserve">
  <value>Do not expose fields in secured types</value>
</data>
    <data name="DoNotExposeFieldsInSecuredTypeMessage" xml:space="preserve">
  <value>Type '{0}' has security demands but exposes public fields: {1}</value>
</data>
    <data name="DoNotExposeFieldsInSecuredTypeDescription" xml:space="preserve">
  <value>Types secured by demands should not expose public fields, as access to these fields is not covered by the declarative demands, potentially leading to security vulnerabilities.</value>
</data>

    <data name="DoNotExposeMethodsProtectedByLinkDemandTitle" xml:space="preserve">
  <value>Do not expose methods that bypass security by calling methods with stricter demands</value>
</data>
    <data name="DoNotExposeMethodsProtectedByLinkDemandMessage" xml:space="preserve">
  <value>Method '{0}' exposes a method protected by a LinkDemand with stricter permissions</value>
</data>
    <data name="DoNotExposeMethodsProtectedByLinkDemandDescription" xml:space="preserve">
  <value>Visible methods should not be less protected than the methods they call if the called methods are protected by a LinkDemand. This could allow bypassing security checks.</value>
</data>

    <data name="DoNotReduceTypeSecurityOnMethodsTitle" xml:space="preserve">
  <value>Do not reduce type security on methods</value>
</data>
    <data name="DoNotReduceTypeSecurityOnMethodsMessage" xml:space="preserve">
  <value>Method '{0}' has security demands that are not a subset of the type's demands</value>
</data>
    <data name="DoNotReduceTypeSecurityOnMethodsDescription" xml:space="preserve">
  <value>Methods in a secured type should not have security permissions that are not a subset of the type's permissions, as this can create security vulnerabilities.</value>
</data>

    <data name="ReviewSealedTypeWithInheritanceDemandTitle" xml:space="preserve">
  <value>Review sealed type with InheritanceDemand</value>
</data>
    <data name="ReviewSealedTypeWithInheritanceDemandMessage" xml:space="preserve">
  <value>Sealed type '{0}' has an InheritanceDemand which will never be enforced</value>
</data>
    <data name="ReviewSealedTypeWithInheritanceDemandDescription" xml:space="preserve">
  <value>Sealed types cannot be inherited from, so any InheritanceDemand on them will never be executed. Check if the permission is required and adjust accordingly.</value>
</data>

    <data name="ReviewSuppressUnmanagedCodeSecurityUsageTitle" xml:space="preserve">
  <value>Review usage of [SuppressUnmanagedCodeSecurity]</value>
</data>
    <data name="ReviewSuppressUnmanagedCodeSecurityUsageMessage" xml:space="preserve">
  <value>Type or method '{0}' is decorated with [SuppressUnmanagedCodeSecurity]</value>
</data>
    <data name="ReviewSuppressUnmanagedCodeSecurityUsageDescription" xml:space="preserve">
  <value>The [SuppressUnmanagedCodeSecurity] attribute reduces security checks when executing unmanaged code. Its usage should be reviewed to ensure no security holes are introduced.</value>
</data>

    <data name="SecureGetObjectDataOverridesTitle" xml:space="preserve">
  <value>Secure GetObjectData overrides</value>
</data>
    <data name="SecureGetObjectDataOverridesMessage" xml:space="preserve">
  <value>GetObjectData method in type '{0}' is not protected with a security demand</value>
</data>
    <data name="SecureGetObjectDataOverridesDescription" xml:space="preserve">
  <value>Types implementing ISerializable should protect their GetObjectData method with a demand or link demand for SerializationFormatter permission to prevent unauthorized access.</value>
</data>

</root>